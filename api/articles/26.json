{"title":"JavaScript DOM2 - 遍历","slug":"26","date":"2020-05-25T11:20:21.000Z","updated":"2022-07-29T04:22:04.783Z","comments":true,"path":"api/articles/26.json","excerpt":" [Figure] ","covers":["https://qny.aqingya.cn/img/d0604444e1eb42ae8d55b1ceae1995ec.jpg","https://img-blog.csdnimg.cn/20200525175136185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d6ZzA4MTc=,size_16,color_FFFFFF,t_70","https://img-blog.csdnimg.cn/20200525175559137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d6ZzA4MTc=,size_16,color_FFFFFF,t_70"],"content":"<p><img src=\"https://qny.aqingya.cn/img/d0604444e1eb42ae8d55b1ceae1995ec.jpg\"></p>\n<span id=\"more\"></span>\n\n<h2 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h2><p>“DOM2级遍历和范围”模块定义了两个用于辅助完成顺序遍历DOM结构的类型: <strong>NodeIterator和TreeWalker</strong>。这两个类型能够基于给定的起点对DOM结构执行<strong>深度优先</strong>( depth-first )的遍历操作。</p>\n<p>DOM遍历是深度优先的DOM结构遍历，也就是说，移动的方向至少有两个(取决于使用的遍历类型)。遍历以给定节点为根，不可能向上超出DOM树的根节点。<br><img src=\"https://img-blog.csdnimg.cn/20200525175136185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d6ZzA4MTc=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>任何节点都可以作为遍历的根节点。如果假设<body>元素为根节点，那么遍历的第一步 就是访问&lt;p&gt;元素，然后再访问同为&lt;body&gt;元素后代的两个文本节点。不过，这次遍历永远不会到达&lt;html&gt;&lt;head&gt;元素，也不会到达不属于&lt;body&gt;元素子树的任何节点。而以document为根节点的遍历则可以访问文档中的全部节点。</p>\n<p>下图展示了对以document为根节点的DOM树进行深度优先遍历的先后顺序。<strong>NodeIterator 和TreeWalker都以这种方式遍历。</strong><br><img src=\"https://img-blog.csdnimg.cn/20200525175559137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d6ZzA4MTc=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"1、NodeIterator\"><a href=\"#1、NodeIterator\" class=\"headerlink\" title=\"1、NodeIterator\"></a>1、NodeIterator</h2><p>使用document.createNodeIterator() 方法来创建它的实例。这个方法接收下列4个参数：</p>\n<blockquote>\n<ul>\n<li>root：想要作为搜索起点的数中的节点。</li>\n<li>whatToShow：表示想要访问哪些节点的数字代码。</li>\n<li>filter：是一个NodeFilter对象，或者一个表示应该接受还是某种特定节点的函数。(类似节点过滤器的函数)</li>\n<li>entityReferenceExpansion：布尔值表示是否扩展实体引用。这个参数在HTML页面中没有用，因为其中的实体引用不能扩展。</li>\n</ul>\n</blockquote>\n<p> whatToShow参数是一个位掩码， 通过应用- -或多 个过滤器( filter )来确定要访问哪些节点。这个参数的值以常量形式在NodeFilter类型中定义，如下所示。</p>\n<blockquote>\n<ul>\n<li>NodeFilter . SHOW_ ALL:显示所有类型的节点。</li>\n<li>NodeFilter . SHOW_ ELEMENT:显示元素节点。</li>\n<li>NodeFilter . SHOW_ ATTRIBUTE:显示特性节点。由于DOM结构原因，实际上不能使用这个值。</li>\n<li>NodeFilter . SHOW_ TEXT:显示文本节点。</li>\n<li>NodeFilter . SHOW_ CDATA_ SECTION: 显示CDATA节点。对HTML页面没有用。</li>\n<li>NodeFilter . SHOw_ ENTITY_ REFERENCE:显示实体引用节点。对HTML页面没有用。</li>\n<li>NodeFil ter . SHOW_ ENTITYE:显示实体节点。对HTML页面没有用。</li>\n<li>NodeFil ter . SHOW_ PROCESSING_ INSTRUCTION:显示处理指令节点。对HTML页面没有用。</li>\n<li>NodeFilter . SHOW_ COMMENT:显示注释节点。</li>\n<li>NodeFilter . SHOW_ DOCUMENT: 显示文档节点。</li>\n<li>NodeFilter . SHOW_ DOCUMENT_TYPE: 显示文档类型节点。</li>\n<li>NodeFil ter . SHOW_ DOCUMENT_ FRAGMENT:显示文档片段节点。对HTML页面没有用。</li>\n<li>NodeFilter . SHOW_ NOTATION:显示符号节点。对HTML页面没有用。</li>\n</ul>\n</blockquote>\n<p>除了NodeFilter.SHOW_ ALL之外，可以使用按位或操作符来组合多个选项，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> whatToShow = NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT;</span><br></pre></td></tr></table></figure>\n<br>\n可以通过createNodeIterator()方法的filter参数来指定自定义的NodeFilter对象，或者指定一个功能类似节点过滤器( node filter )的函数。 \n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> filter = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">node</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node.tagName.toLowerCase() == <span class=\"string\">&quot;li&quot;</span>?</span><br><span class=\"line\">    NodeFilter.FILTER_ACCEPT:</span><br><span class=\"line\">    NodeFilter.FILTER_SKIP;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>NodeIterator类型的两个主要方法是<strong>nextNode ()<strong>和p</strong>reviousNode()<strong>。顾名思义，在深度优先的DOM子树遍历中，nextNode ()方法用于向前前进一步，而previousNode ()用于向后后退一步。</strong>在刚刚创建的NodeIterator对象中，有一个内部指针指向根节点，因此第一次调用nextNode()会返回根节点。当遍历到DOM子树的最后一个节点时，nextNode() 返回null</strong>。previousNode()方法的工作机制类似。当遍历到DOM子树的最后一个节点，且previousNode()返回根节点之后，再次调用它就会返回null。</p>\n<hr>\n<p>小例子：遍历指定节点中 &lt;li&gt;的元素，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mylist = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;mylist&quot;</span>);  <span class=\"comment\">//获取我们遍历起点的节点。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> filter = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">node</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node.tagName.toLowerCase() == <span class=\"string\">&quot;li&quot;</span>?</span><br><span class=\"line\">    NodeFilter.FILTER_ACCEPT:</span><br><span class=\"line\">    NodeFilter.FILTER_SKIP;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> iterator = <span class=\"built_in\">document</span>.createNodeIterator(mylist, NodeFilter.SHOW_ELEMENT, filter, <span class=\"literal\">false</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> node = iterator.nextNode;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (node !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(node.tagName)  <span class=\"comment\">//输出标签名</span></span><br><span class=\"line\">    node = iterator.nextNode();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<br>\n\n<h2 id=\"TrreWalker\"><a href=\"#TrreWalker\" class=\"headerlink\" title=\"TrreWalker\"></a>TrreWalker</h2><p>TreeWalker是NodeIterator的一个更高级 的版本。除了包括 nextNode ()和previousNode ()在内的相同的功能之外，这个类型还提供了下列用于在不同方向上遍历DOM结构的方法。</p>\n<blockquote>\n<ul>\n<li>parentNode():遍历到当前节点的父节点;</li>\n<li>firstChild():遍历到当前节点的第一个子节点;</li>\n<li>lastChild():遍历到当前节点的最后一个子节点;</li>\n<li>nextSibling():遍历到当前节点的下一个同辈节点;</li>\n<li>previoussibling():遍历到当前节点的上一个同辈节点。</li>\n</ul>\n</blockquote>\n<p>创建Treewalker对象要使用document. createTreewalker()方法，这个方法接受的4个参数与document . createNodeIterator ()方法相同:作为遍历起点的根节点、要显示的节点类型、过滤器和一个表示是否扩展实体引用的布尔值。由于这两个创建方法很相似，所以很容易用Treewalker 来代替NodeIterator,如下面的例子所示。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mylist = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;mylist&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">var</span> filter = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">node</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> node.tagName.toLowerCase() == <span class=\"string\">&quot;li&quot;</span> ?</span><br><span class=\"line\">                    NodeFilter.FILTER_ACCEPT :</span><br><span class=\"line\">                    NodeFilter.FILTER_SKIP;</span><br><span class=\"line\">                <span class=\"comment\">// NodeFilter.FILTER_REJECT;</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> walker = <span class=\"built_in\">document</span>.createTreeWalker(mylist, NodeFilter.SHOW_ELEMENT, filter, <span class=\"literal\">false</span>);</span><br><span class=\"line\">            <span class=\"keyword\">var</span> node = walker.nextNode;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (node !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(node.tagName)  <span class=\"comment\">//输出标签名</span></span><br><span class=\"line\">                node = walker.nextNode();</span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure>\n<p>在这里，filter可以返回的值有所不同。除了NodeFilter .FILTER_ACCEPT 和NodeFilter.FILTER_ SKIP之外，还可以使用NodeFilter . FILTER_REJECT。 在使用NodeIterator对象时，NodeFilter . FILTER_ SKIP与NodeFilter . FILTER_ REJECT 的作用相同:跳过指定的节点。但在使用TreeWalker对象时，NodeFilter . FILTER <em>SKIP会跳过相应节点继续前进到子树中的下一个节点，而NodeFilter . FILTER</em> REJECT 则会跳过相应节点及该节点的整个子树。例如，将前面例子中的NodeFilter . FILTER_ SKIP 修改成NodeFilter. FILTER_ <em>REJECT, 结果就是不会访问任何节点。这是因为第一个返回的节点是&lt;div&gt;,它的标签名不是”li”，于是就会返回NodeFilter . FILTER</em> REJECT ，这意味着遍历会跳过整个子树。在这个例子中，&lt;div&gt;元素是遍历的根节点，于是结果就会停止遍历。</p>\n<p>当然，Treewalker真正强大的地方在于能够在DOM结构中沿任何方向移动。使用Treewalker遍历DOM树，即使不定义过滤器，也可以取得所有&lt;li&gt;元素，如下面的代码所示。<span style=\"color:red;\"><strong>（前提我们知道它的结构树）</strong></sapn></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mylist = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;mylist&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> walker = <span class=\"built_in\">document</span>.createTreeWalker(mylist, NodeFilter.SHOW_ELEMENT, <span class=\"literal\">null</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">walker.firstChild(); <span class=\"comment\">//转到 &lt;p&gt;</span></span><br><span class=\"line\">walker.nextSibling() <span class=\"comment\">//转到&lt;ul&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> node = walker.firstChild();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (node !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(node.tagName)    </span><br><span class=\"line\">    node = walker.nextSibling();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它的HTML结构</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">&quot;mylist&quot;</span>&gt;</span><br><span class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>sdfsdf<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;li&quot;</span>&gt;</span>阿<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>清<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>呀<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span></span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>TreeWalker类型 还有一个属性，名叫 currentNode ，表示任何遍历方法在上一次遍历中返回的节点。通过设置这个属性也可以修改遍历继续进行起点，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> node = walker.nextNode;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(node === walker.currentNode); <span class=\"comment\">//ture</span></span><br><span class=\"line\">walker.currentNode = <span class=\"built_in\">document</span>.body; <span class=\"comment\">//修改起点</span></span><br></pre></td></tr></table></figure>\n<br>\n\n<p>下面的例子会返回body中所有的 li 节点</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mylist = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;mylist&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> filter = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">node</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node.tagName.toLowerCase() == <span class=\"string\">&quot;li&quot;</span> ?</span><br><span class=\"line\">        NodeFilter.FILTER_ACCEPT :</span><br><span class=\"line\">        NodeFilter.FILTER_SKIP;</span><br><span class=\"line\">    <span class=\"comment\">// NodeFilter.FILTER_REJECT;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> walker = <span class=\"built_in\">document</span>.createTreeWalker(mylist, NodeFilter.SHOW_ELEMENT, filter, <span class=\"literal\">false</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> node = walker.nextNode;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(node === walker.currentNode); <span class=\"comment\">//ture</span></span><br><span class=\"line\">walker.currentNode = <span class=\"built_in\">document</span>.body; <span class=\"comment\">//修改起点</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (node !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(node.tagName)</span><br><span class=\"line\">    node = walker.nextNode();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<br>\n<br>\n愿你的坚持终有收获。\n<br>\n<br>\n","more":"<h2 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h2><p>“DOM2级遍历和范围”模块定义了两个用于辅助完成顺序遍历DOM结构的类型: <strong>NodeIterator和TreeWalker</strong>。这两个类型能够基于给定的起点对DOM结构执行<strong>深度优先</strong>( depth-first )的遍历操作。</p>\n<p>DOM遍历是深度优先的DOM结构遍历，也就是说，移动的方向至少有两个(取决于使用的遍历类型)。遍历以给定节点为根，不可能向上超出DOM树的根节点。<br><img src=\"https://img-blog.csdnimg.cn/20200525175136185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d6ZzA4MTc=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>任何节点都可以作为遍历的根节点。如果假设<body>元素为根节点，那么遍历的第一步 就是访问&lt;p&gt;元素，然后再访问同为&lt;body&gt;元素后代的两个文本节点。不过，这次遍历永远不会到达&lt;html&gt;&lt;head&gt;元素，也不会到达不属于&lt;body&gt;元素子树的任何节点。而以document为根节点的遍历则可以访问文档中的全部节点。</p>\n<p>下图展示了对以document为根节点的DOM树进行深度优先遍历的先后顺序。<strong>NodeIterator 和TreeWalker都以这种方式遍历。</strong><br><img src=\"https://img-blog.csdnimg.cn/20200525175559137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d6ZzA4MTc=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"1、NodeIterator\"><a href=\"#1、NodeIterator\" class=\"headerlink\" title=\"1、NodeIterator\"></a>1、NodeIterator</h2><p>使用document.createNodeIterator() 方法来创建它的实例。这个方法接收下列4个参数：</p>\n<blockquote>\n<ul>\n<li>root：想要作为搜索起点的数中的节点。</li>\n<li>whatToShow：表示想要访问哪些节点的数字代码。</li>\n<li>filter：是一个NodeFilter对象，或者一个表示应该接受还是某种特定节点的函数。(类似节点过滤器的函数)</li>\n<li>entityReferenceExpansion：布尔值表示是否扩展实体引用。这个参数在HTML页面中没有用，因为其中的实体引用不能扩展。</li>\n</ul>\n</blockquote>\n<p> whatToShow参数是一个位掩码， 通过应用- -或多 个过滤器( filter )来确定要访问哪些节点。这个参数的值以常量形式在NodeFilter类型中定义，如下所示。</p>\n<blockquote>\n<ul>\n<li>NodeFilter . SHOW_ ALL:显示所有类型的节点。</li>\n<li>NodeFilter . SHOW_ ELEMENT:显示元素节点。</li>\n<li>NodeFilter . SHOW_ ATTRIBUTE:显示特性节点。由于DOM结构原因，实际上不能使用这个值。</li>\n<li>NodeFilter . SHOW_ TEXT:显示文本节点。</li>\n<li>NodeFilter . SHOW_ CDATA_ SECTION: 显示CDATA节点。对HTML页面没有用。</li>\n<li>NodeFilter . SHOw_ ENTITY_ REFERENCE:显示实体引用节点。对HTML页面没有用。</li>\n<li>NodeFil ter . SHOW_ ENTITYE:显示实体节点。对HTML页面没有用。</li>\n<li>NodeFil ter . SHOW_ PROCESSING_ INSTRUCTION:显示处理指令节点。对HTML页面没有用。</li>\n<li>NodeFilter . SHOW_ COMMENT:显示注释节点。</li>\n<li>NodeFilter . SHOW_ DOCUMENT: 显示文档节点。</li>\n<li>NodeFilter . SHOW_ DOCUMENT_TYPE: 显示文档类型节点。</li>\n<li>NodeFil ter . SHOW_ DOCUMENT_ FRAGMENT:显示文档片段节点。对HTML页面没有用。</li>\n<li>NodeFilter . SHOW_ NOTATION:显示符号节点。对HTML页面没有用。</li>\n</ul>\n</blockquote>\n<p>除了NodeFilter.SHOW_ ALL之外，可以使用按位或操作符来组合多个选项，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> whatToShow = NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT;</span><br></pre></td></tr></table></figure>\n<br>\n可以通过createNodeIterator()方法的filter参数来指定自定义的NodeFilter对象，或者指定一个功能类似节点过滤器( node filter )的函数。 \n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> filter = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">node</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node.tagName.toLowerCase() == <span class=\"string\">&quot;li&quot;</span>?</span><br><span class=\"line\">    NodeFilter.FILTER_ACCEPT:</span><br><span class=\"line\">    NodeFilter.FILTER_SKIP;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>NodeIterator类型的两个主要方法是<strong>nextNode ()<strong>和p</strong>reviousNode()<strong>。顾名思义，在深度优先的DOM子树遍历中，nextNode ()方法用于向前前进一步，而previousNode ()用于向后后退一步。</strong>在刚刚创建的NodeIterator对象中，有一个内部指针指向根节点，因此第一次调用nextNode()会返回根节点。当遍历到DOM子树的最后一个节点时，nextNode() 返回null</strong>。previousNode()方法的工作机制类似。当遍历到DOM子树的最后一个节点，且previousNode()返回根节点之后，再次调用它就会返回null。</p>\n<hr>\n<p>小例子：遍历指定节点中 &lt;li&gt;的元素，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mylist = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;mylist&quot;</span>);  <span class=\"comment\">//获取我们遍历起点的节点。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> filter = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">node</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node.tagName.toLowerCase() == <span class=\"string\">&quot;li&quot;</span>?</span><br><span class=\"line\">    NodeFilter.FILTER_ACCEPT:</span><br><span class=\"line\">    NodeFilter.FILTER_SKIP;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> iterator = <span class=\"built_in\">document</span>.createNodeIterator(mylist, NodeFilter.SHOW_ELEMENT, filter, <span class=\"literal\">false</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> node = iterator.nextNode;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (node !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(node.tagName)  <span class=\"comment\">//输出标签名</span></span><br><span class=\"line\">    node = iterator.nextNode();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<br>\n\n<h2 id=\"TrreWalker\"><a href=\"#TrreWalker\" class=\"headerlink\" title=\"TrreWalker\"></a>TrreWalker</h2><p>TreeWalker是NodeIterator的一个更高级 的版本。除了包括 nextNode ()和previousNode ()在内的相同的功能之外，这个类型还提供了下列用于在不同方向上遍历DOM结构的方法。</p>\n<blockquote>\n<ul>\n<li>parentNode():遍历到当前节点的父节点;</li>\n<li>firstChild():遍历到当前节点的第一个子节点;</li>\n<li>lastChild():遍历到当前节点的最后一个子节点;</li>\n<li>nextSibling():遍历到当前节点的下一个同辈节点;</li>\n<li>previoussibling():遍历到当前节点的上一个同辈节点。</li>\n</ul>\n</blockquote>\n<p>创建Treewalker对象要使用document. createTreewalker()方法，这个方法接受的4个参数与document . createNodeIterator ()方法相同:作为遍历起点的根节点、要显示的节点类型、过滤器和一个表示是否扩展实体引用的布尔值。由于这两个创建方法很相似，所以很容易用Treewalker 来代替NodeIterator,如下面的例子所示。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mylist = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;mylist&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">var</span> filter = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">node</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> node.tagName.toLowerCase() == <span class=\"string\">&quot;li&quot;</span> ?</span><br><span class=\"line\">                    NodeFilter.FILTER_ACCEPT :</span><br><span class=\"line\">                    NodeFilter.FILTER_SKIP;</span><br><span class=\"line\">                <span class=\"comment\">// NodeFilter.FILTER_REJECT;</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> walker = <span class=\"built_in\">document</span>.createTreeWalker(mylist, NodeFilter.SHOW_ELEMENT, filter, <span class=\"literal\">false</span>);</span><br><span class=\"line\">            <span class=\"keyword\">var</span> node = walker.nextNode;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (node !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(node.tagName)  <span class=\"comment\">//输出标签名</span></span><br><span class=\"line\">                node = walker.nextNode();</span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure>\n<p>在这里，filter可以返回的值有所不同。除了NodeFilter .FILTER_ACCEPT 和NodeFilter.FILTER_ SKIP之外，还可以使用NodeFilter . FILTER_REJECT。 在使用NodeIterator对象时，NodeFilter . FILTER_ SKIP与NodeFilter . FILTER_ REJECT 的作用相同:跳过指定的节点。但在使用TreeWalker对象时，NodeFilter . FILTER <em>SKIP会跳过相应节点继续前进到子树中的下一个节点，而NodeFilter . FILTER</em> REJECT 则会跳过相应节点及该节点的整个子树。例如，将前面例子中的NodeFilter . FILTER_ SKIP 修改成NodeFilter. FILTER_ <em>REJECT, 结果就是不会访问任何节点。这是因为第一个返回的节点是&lt;div&gt;,它的标签名不是”li”，于是就会返回NodeFilter . FILTER</em> REJECT ，这意味着遍历会跳过整个子树。在这个例子中，&lt;div&gt;元素是遍历的根节点，于是结果就会停止遍历。</p>\n<p>当然，Treewalker真正强大的地方在于能够在DOM结构中沿任何方向移动。使用Treewalker遍历DOM树，即使不定义过滤器，也可以取得所有&lt;li&gt;元素，如下面的代码所示。<span style=\"color:red;\"><strong>（前提我们知道它的结构树）</strong></sapn></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mylist = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;mylist&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> walker = <span class=\"built_in\">document</span>.createTreeWalker(mylist, NodeFilter.SHOW_ELEMENT, <span class=\"literal\">null</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">walker.firstChild(); <span class=\"comment\">//转到 &lt;p&gt;</span></span><br><span class=\"line\">walker.nextSibling() <span class=\"comment\">//转到&lt;ul&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> node = walker.firstChild();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (node !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(node.tagName)    </span><br><span class=\"line\">    node = walker.nextSibling();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它的HTML结构</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">&quot;mylist&quot;</span>&gt;</span><br><span class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>sdfsdf<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;li&quot;</span>&gt;</span>阿<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>清<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>呀<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span></span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>TreeWalker类型 还有一个属性，名叫 currentNode ，表示任何遍历方法在上一次遍历中返回的节点。通过设置这个属性也可以修改遍历继续进行起点，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> node = walker.nextNode;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(node === walker.currentNode); <span class=\"comment\">//ture</span></span><br><span class=\"line\">walker.currentNode = <span class=\"built_in\">document</span>.body; <span class=\"comment\">//修改起点</span></span><br></pre></td></tr></table></figure>\n<br>\n\n<p>下面的例子会返回body中所有的 li 节点</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mylist = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;mylist&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> filter = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">node</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node.tagName.toLowerCase() == <span class=\"string\">&quot;li&quot;</span> ?</span><br><span class=\"line\">        NodeFilter.FILTER_ACCEPT :</span><br><span class=\"line\">        NodeFilter.FILTER_SKIP;</span><br><span class=\"line\">    <span class=\"comment\">// NodeFilter.FILTER_REJECT;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> walker = <span class=\"built_in\">document</span>.createTreeWalker(mylist, NodeFilter.SHOW_ELEMENT, filter, <span class=\"literal\">false</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> node = walker.nextNode;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(node === walker.currentNode); <span class=\"comment\">//ture</span></span><br><span class=\"line\">walker.currentNode = <span class=\"built_in\">document</span>.body; <span class=\"comment\">//修改起点</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (node !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(node.tagName)</span><br><span class=\"line\">    node = walker.nextNode();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<br>\n<br>\n愿你的坚持终有收获。\n<br>\n<br>","categories":[{"name":"DOM","path":"api/categories/DOM.json"}],"tags":[{"name":"JavaScript","path":"api/tags/JavaScript.json"},{"name":"DOM","path":"api/tags/DOM.json"}]}