{"title":"VueX 详解","slug":"78-1","date":"2020-08-03T14:34:29.000Z","updated":"2022-07-29T04:22:04.764Z","comments":true,"path":"api/articles/78-1.json","excerpt":" [Figure] ","covers":["https://cdn.jsdelivr.net/gh/wuzhiguang1/bolgfile@1.2/photo/IMG_0085.JPG","https://qny.aqingya.cn/img/20200803204415.png","https://qny.aqingya.cn/img/20200803204525.png","https://qny.aqingya.cn/img/3262362.png","https://qny.aqingya.cn/img/20200803210504.png","https://qny.aqingya.cn/img/20200803221526.png","https://qny.aqingya.cn/img/20200803222114.png","https://qny.aqingya.cn/img/20200803222301.png","https://qny.aqingya.cn/img/image-20200803222537327.png","https://qny.aqingya.cn/img/20200803223121.png","https://qny.aqingya.cn/img/20200805105113.png","https://qny.aqingya.cn/img/20200805105441.png","https://qny.aqingya.cn/img/20200805105503.png","https://qny.aqingya.cn/img/20200805110256.png","https://qny.aqingya.cn/img/20200805111557.png","https://qny.aqingya.cn/img/20200805111642.png","https://qny.aqingya.cn/img/20200805111715.png","https://qny.aqingya.cn/img/20200805112206.png","https://qny.aqingya.cn/img/20200805112235.png","https://qny.aqingya.cn/img/20200805112425.png","https://qny.aqingya.cn/img/20200805123705.png","https://qny.aqingya.cn/img/20200805123712.png","https://qny.aqingya.cn/img/20200805125539.png","https://qny.aqingya.cn/img/20200805125706.png","https://qny.aqingya.cn/img/20200805130005.png","https://qny.aqingya.cn/img/20200805130521.png","https://qny.aqingya.cn/img/20200805132013.png","https://qny.aqingya.cn/img/20200805132245.png","https://qny.aqingya.cn/img/20200805132401.png","https://qny.aqingya.cn/img/20200805133804.png","https://qny.aqingya.cn/img/20200805133945.png","https://qny.aqingya.cn/img/20200805133923.png","https://qny.aqingya.cn/img/20200805134049.png","https://qny.aqingya.cn/img/20200805143849.png","https://qny.aqingya.cn/img/20200805145123.png","https://qny.aqingya.cn/img/20200805145238.png","https://qny.aqingya.cn/img/20200805145756.png","https://qny.aqingya.cn/img/20200805150117.png","https://qny.aqingya.cn/img/20200805150834.png","https://qny.aqingya.cn/img/20200805154317.png","https://qny.aqingya.cn/img/20200805154343.png","https://qny.aqingya.cn/img/20200805154401.png","https://qny.aqingya.cn/img/20200805160041.png","https://qny.aqingya.cn/img/20200805160026.png","https://qny.aqingya.cn/img/20200805165816.png","https://qny.aqingya.cn/img/20200805171504.png","https://qny.aqingya.cn/img/20200805171043.png","https://qny.aqingya.cn/img/20200805174501.png","https://qny.aqingya.cn/img/20200805182102.png","https://qny.aqingya.cn/img/20200805191650.png","https://qny.aqingya.cn/img/20200805191738.png","https://qny.aqingya.cn/img/20200805192023.png","https://qny.aqingya.cn/img/20200805194232.png","https://qny.aqingya.cn/img/20200805195748.png","https://qny.aqingya.cn/img/20200805201122.png","https://qny.aqingya.cn/img/20200805204221.png","https://qny.aqingya.cn/img/20200805205448.png","https://qny.aqingya.cn/img/20200805210644.png","https://qny.aqingya.cn/img/20200820095835.png","https://qny.aqingya.cn/img/20200820095901.png","https://qny.aqingya.cn/img/20200820095953.png"],"content":"<p><img src=\"https://cdn.jsdelivr.net/gh/wuzhiguang1/bolgfile@1.2/photo/IMG_0085.JPG\"></p>\n<span id=\"more\"></span>\n\n\n\n<h2 id=\"认识VueX\"><a href=\"#认识VueX\" class=\"headerlink\" title=\"认识VueX\"></a>认识VueX</h2><p><a href=\"https://vuex.vuejs.org/zh/\">Vuex官网地址</a></p>\n<h3 id=\"Vuex是做什么的\"><a href=\"#Vuex是做什么的\" class=\"headerlink\" title=\"Vuex是做什么的?\"></a>Vuex是做什么的?</h3><p>🔷 官方解释：Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。</p>\n<p>&emsp;&emsp;🔹 它采用 集中式存储管理 应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>\n<p>&emsp;&emsp;🔹 Vuex 也集成到 Vue 的官方调试工具 <a href=\"https://github.com/vuejs/vue-devtools\">devtools</a><a href=\"https://github.com/vuejs/vue-devtools\"> extension</a>，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。</p>\n<br>\n\n<p><strong>🔷 状态管理</strong>到底是什么？</p>\n<p>&emsp;&emsp;<strong>🔹 状态管理模式、集中式存储管理</strong>这些名词听起来就非常高大上，让人捉摸不透。</p>\n<p>&emsp;&emsp;🔹 其实，你可以简单的将其看成把需要多个组件共享的变量全部存储在一个对象里面。</p>\n<p>&emsp;&emsp;🔹 然后，将这个对象放在顶层的Vue实例中，让其他组件可以使用。</p>\n<p>&emsp;&emsp;🔹 那么，多个组件就可以共享这个对象中的所有变量属性.</p>\n<br>\n\n<p><span style=\"color:red\">Vuex就是为了提供这样一个在多个组件间共享状态的插件，而且是响应式的。</span></p>\n<br>\n\n\n\n<p>🔷 管理什么状态呢 ?</p>\n<p>&emsp;&emsp;🔹 如果你做过大型开放，你一定遇到过多个状态，在多个界面间的共享问题。</p>\n<p>&emsp;&emsp;🔹 比如用户的登录状态、用户名称、头像、地理位置信息等等。</p>\n<p>&emsp;&emsp;🔹 比如商品的收藏、购物车中的物品等等。</p>\n<p>&emsp;&emsp;🔹 这些状态信息，我们都可以放在统一的地方，对它进行保存和管理，而且它们还是响应式的</p>\n<br>\n\n<p>✔ 单页面的状态管理———————————————————————————————</p>\n<br>\n\n<p>我们知道，要在单个组件中进行状态管理是一件非常简单的事情</p>\n<p>什么意思呢？我们来看下面的图片。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200803204415.png\"></p>\n<p>🔷 这图片中的三种东西，怎么理解呢？</p>\n<p>&emsp;&emsp;🔹 State：不用多说，就是我们的状态。（你姑且可以当做就是data中的属性）</p>\n<p>&emsp;&emsp;🔹 View：视图层，可以针对State的变化，显示不同的信息。（这个好理解吧？）</p>\n<p>&emsp;&emsp;🔹 Actions：这里的Actions主要是用户的各种操作：点击、输入等等，会导致状态的改变。</p>\n<br>\n\n<p>举个简单的例子:</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200803204525.png\"></p>\n<p>我们来实现这样的一个简单的小案例。</p>\n<p><img src=\"https://qny.aqingya.cn/img/3262362.png\"></p>\n<p>🔷 在这个案例中，我们有木有状态需要管理呢？没错，就是个数counter。</p>\n<p>🔷 counter需要某种方式被记录下来，也就是我们的State。</p>\n<p>🔷 counter目前的值需要被显示在界面中，也就是我们的View部分。</p>\n<p>🔷 界面发生某些操作时（我们这里是用户的点击，也可以是用户的input），需要去更新状态，也就是我们的Actions</p>\n<p>这不就是上面的流程图了吗？</p>\n<br>\n\n<p>✔ 多状态管理———————————————————————————————</p>\n<br>\n\n\n\n<p>🔷 Vue已经帮我们做好了单个界面的状态管理，但是如果是多个界面呢？</p>\n<p>&emsp;&emsp;🔹 多个试图都依赖同一个状态（一个状态改了，多个界面需要进行更新）</p>\n<p>&emsp;&emsp;🔹 不同界面的Actions都想修改同一个状态（Home.vue需要修改，Profile.vue也需要修改这个状态）</p>\n<p>🔷 也就是说对于某些状态(状态1/状态2/状态3)来说只属于我们某一个试图，但是也有一些状态(状态a/状态b/状态c)属于多个试图共同想要维护的。</p>\n<p>&emsp;&emsp;🔹 状态1/状态2/状态3你放在自己的房间中，你自己管理自己用，没问题。</p>\n<p>&emsp;&emsp;🔹 但是状态a/状态b/状态c我们希望交给一个大管家来统一帮助我们管理！！！</p>\n<p>&emsp;&emsp;🔹 没错，Vuex就是为我们提供这个大管家的工具。</p>\n<p>🔷 全局单例模式（大管家）</p>\n<p>&emsp;&emsp;🔹 我们现在要做的就是将共享的状态抽取出来，交给我们的大管家，统一进行管理。</p>\n<p>&emsp;&emsp;🔹 之后，你们每个试图，按照我<strong>规定好的</strong>规定，进行访问和修改等操作。</p>\n<p>这就是Vuex背后的基本思想。</p>\n<br>\n\n<p>✔ Vuex状态管理图例—————————-</p>\n<br>\n\n<p>当我们去修改Vuex 中的 State的时候，我们不应该直接去修改 State ，而是通过 Actions、Mutations 进而来修改State。</p>\n<p>Devtools：它是Vue开发的一个浏览器插件，通过Mutations，它可以记录我们每一次修改State。</p>\n<p>Actions：如果我们请求是异步操作的话，我们会通过Actions，将异步转化为同步，因为Devtools通过Mutations来监听我们对 State 的修改只能是同步操作。如果请求是同步的话，我们可以绕过Actions。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200803210504.png\"></p>\n<br>\n\n<h2 id=\"Vuex插件的安装\"><a href=\"#Vuex插件的安装\" class=\"headerlink\" title=\"Vuex插件的安装\"></a>Vuex插件的安装</h2><p>安装生产时依赖：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cnpm install vuex --save</span><br></pre></td></tr></table></figure>\n\n<be>\n\n\n\n<h2 id=\"Vuex-基本使用\"><a href=\"#Vuex-基本使用\" class=\"headerlink\" title=\"Vuex 基本使用\"></a>Vuex 基本使用</h2><p>我们还是实现一下之前简单的案例</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200803221526.png\"></p>\n<p>🔷 首先，我们需要在某个地方存放我们的Vuex代码：</p>\n<p>  &emsp;&emsp; 🔹 这里，我们先创建一个文件夹store，并且在其中创建一个index.js文件</p>\n<p>&emsp;&emsp;   🔹 在index.js文件中写入如下代码：</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200803222114.png\"></p>\n<br>\n\n<p><strong>✔ 挂载到</strong>Vue实例中</p>\n<p>🔷其次，我们让所有的Vue组件都可以使用这个store对象</p>\n<p>&emsp;&emsp;  🔹 来到main.js文件，导入store对象，并且放在new Vue中</p>\n<p>&emsp;&emsp;  🔹 这样，在其他Vue组件中，我们就可以通过this.$store的方式，获取到这个store对象了</p>\n<p>挂载到Vue实例中 相当于执行 <code>Vue.prototype.$store = store</code> ，将store对象放置在new Vue对象中，这样可以保证在所有的组件中都可以使用到。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200803222301.png\"></p>\n<br>\n\n<p>✔ 使用Vuex</p>\n<p><img src=\"https://qny.aqingya.cn/img/image-20200803222537327.png\"></p>\n<br>\n\n<p>🔷我们来对使用步骤，做一个简单的小节：</p>\n<p>&emsp;&emsp;🔹  1.提取出一个公共的store对象，用于保存在多个组件中共享的状态。</p>\n<p>&emsp;&emsp;🔹  2.将store对象放置在new Vue对象中，这样可以保证在所有的组件中都可以使用到</p>\n<p>&emsp;&emsp;🔹  3.在其他组件中使用store对象中保存的状态即可</p>\n<p>&emsp;&emsp;&emsp;&emsp; 通过<code>this.$store.state</code>.属性的方式来访问状态</p>\n<p>&emsp;&emsp;&emsp;&emsp; 通过<code>this.$store.commit(&#39;mutation中方法&#39;)</code>来修改状态</p>\n<br>\n\n<p>🔷注意事项：</p>\n<p>&emsp;&emsp;🔹 我们是通过提交mutation的方式，而非直接改变store.state.count。</p>\n<p>&emsp;&emsp;🔹 这是因为Vuex可以更明确的追踪状态的变化，所以不要直接改变store.state.count的值。</p>\n<br>\n\n<p>所以 可以通过浏览器插件Devtools来跟踪 state 的状态。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200803223121.png\"></p>\n<br>\n\n<h2 id=\"Vuex核心概念\"><a href=\"#Vuex核心概念\" class=\"headerlink\" title=\"Vuex核心概念\"></a>Vuex核心概念</h2><br>\n\n<h3 id=\"State\"><a href=\"#State\" class=\"headerlink\" title=\"State\"></a>State</h3><p>🔷Vuex提出使用单一状态树, 什么是单一状态树呢？</p>\n<p>&emsp;&emsp;🔹 英文名称是Single Source of Truth，也可以翻译成单一数据源。</p>\n<p>🔷但是，它是什么呢？我们来看一个生活中的例子。</p>\n<p>&emsp;&emsp;🔹 OK，我用一个生活中的例子做一个简单的类比。</p>\n<p>&emsp;&emsp;🔹 我们知道，在国内我们有很多的信息需要被记录，比如上学时的个人档案，工作后的社保记录，公积金记录，结婚后的婚姻信息，以及其他相关的户口、医疗、文凭、房产记录等等（还有很多信息）。</p>\n<p>&emsp;&emsp;🔹 这些信息被分散在很多地方进行管理，有一天你需要办某个业务时(比如入户某个城市)，你会发现你需要到各个对应的工作地点去打印、盖章各种资料信息，最后到一个地方提交证明你的信息无误。</p>\n<p>&emsp;&emsp;🔹 这种保存信息的方案，不仅仅低效，而且不方便管理，以及日后的维护也是一个庞大的工作(需要大量的各个部门的人力来维护，当然国家目前已经在完善我们的这个系统了)。</p>\n<br>\n\n<p>🔷这个和我们在应用开发中比较类似：</p>\n<p>&emsp;&emsp;🔹 如果你的状态信息是保存到多个Store对象中的，那么之后的管理和维护等等都会变得特别困难。</p>\n<p>&emsp;&emsp;🔹 <span style=\"color:red\">所以Vuex也使用了单一状态树来管理应用层级的全部状态。</span></p>\n<p>&emsp;&emsp;🔹 <span style=\"color:red\">单一状态树能够让我们最直接的方式找到某个状态的片段，而且在之后的维护和调试过程中，也可以非常方便的管理和维护。</span></p>\n<br>\n\n\n\n<h3 id=\"Getters\"><a href=\"#Getters\" class=\"headerlink\" title=\"Getters\"></a>Getters</h3><p>有时候，我们需要从Stare中获取的一些经过改变的数据，我们就可以使用Getters。这比较类似于<a href=\"https://aqingya.cn/articl/3a0cc30e.html#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7-computed\">计算属性</a>。</p>\n<p>Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p>\n<p>举个简单的例子：在State中有一个数组，包含一些学生的基本信息。我们需要拿到age 大于18 的学生的信息，我们就可以使用Getters。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805105113.png\"></p>\n<br>\n\n<p>使用getters  <code>&lt;h2&gt;&#123;&#123;$store.getters.more18age&#125;&#125;&lt;/h2&gt;</code></p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805105441.png\"></p>\n<p>就获取到了age 大于18 的学生信息。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805105503.png\"></p>\n<hr>\n<p><br>要是放在以前，我们可能会使用computed属性。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805110256.png\"></p>\n<p>但是也有一个缺点，比如我们想要在多个组件中都同样的数据变换，那么我们都在在各种的组件中设置同样的computed，这样很不好。我们就可以使用vuex里的gitters属性。</p>\n<br>\n\n<hr>\n<br>\n\n<p>我们在提一个需求：要得到年纪大于18 的学生的人数。我们就可以这样来做。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805111557.png\"></p>\n<p>使用该函数：<code>$store.getters.more18ageLength</code></p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805111642.png\"></p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805111715.png\"></p>\n<br>\n\n<p>我们再来看一个需求，我们不要把age写死，而是当做参数传递进来。</p>\n<p>首先我们想到 的是直接在moreage中传递参数，但是这样是不行的，我们可以return 一个函数，在这个函数中传入参数，这样我们在使用的时候就可以，<code>$store.getters.moreage(20)</code> 。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805112206.png\"></p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805112235.png\"></p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805112425.png\"></p>\n<br>\n\n<p>总结：</p>\n<p><span style=\"color:red\">🔹 如果我们没有传递参数的时候，我们就可以在getters中直接定义一个函数。</span></p>\n<p><span style=\"color:red\">🔹 如果我们需要使用我们在getters中定义过的属性，我们就可以在定义函数的时候，将getters做为第二个参数传递进去。</span></p>\n<p><span style=\"color:red\">🔹 如果我们需要在函数中传递参数，只能让getters本身返回另一个函数。参数定义在这个函数中，在使用是时候就可以传递参数了。</span></p>\n<br>\n\n<hr>\n<h4 id=\"通过属性访问\"><a href=\"#通过属性访问\" class=\"headerlink\" title=\"通过属性访问\"></a>通过属性访问</h4><p>Getter 会暴露为 <code>store.getters</code> 对象，你可以以属性的形式访问这些值：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.getters.doneTodos <span class=\"comment\">// -&gt; [&#123; id: 1, text: &#x27;...&#x27;, done: true &#125;]</span></span><br></pre></td></tr></table></figure>\n\n<p>Getter 也可以接受其他 getter 作为第二个参数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getters: &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"attr\">doneTodosCount</span>: <span class=\"function\">(<span class=\"params\">state, getters</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getters.doneTodos.length</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">store.getters.doneTodosCount <span class=\"comment\">// -&gt; 1</span></span><br></pre></td></tr></table></figure>\n\n<p>我们可以很容易地在任何组件中使用它：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: &#123;</span><br><span class=\"line\">  doneTodosCount () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.$store.getters.doneTodosCount</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意，getter 在通过属性访问时是作为 Vue 的响应式系统的一部分缓存其中的。</p>\n<br>\n\n<h4 id=\"通过方法访问\"><a href=\"#通过方法访问\" class=\"headerlink\" title=\"通过方法访问\"></a>通过方法访问</h4><p>你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getters: &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"attr\">getTodoById</span>: <span class=\"function\">(<span class=\"params\">state</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">id</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> state.todos.find(<span class=\"function\"><span class=\"params\">todo</span> =&gt;</span> todo.id === id)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">store.getters.getTodoById(<span class=\"number\">2</span>) <span class=\"comment\">// -&gt; &#123; id: 2, text: &#x27;...&#x27;, done: false &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>注意，getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。</p>\n<br>\n\n<h4 id=\"mapGetters-辅助函数\"><a href=\"#mapGetters-辅助函数\" class=\"headerlink\" title=\"mapGetters 辅助函数\"></a><code>mapGetters</code> 辅助函数</h4><p><code>mapGetters</code> 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapGetters &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vuex&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"attr\">computed</span>: &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 使用对象展开运算符将 getter 混入 computed 对象中</span></span><br><span class=\"line\">    ...mapGetters([</span><br><span class=\"line\">      <span class=\"string\">&#x27;doneTodosCount&#x27;</span>,</span><br><span class=\"line\">      <span class=\"string\">&#x27;anotherGetter&#x27;</span>,</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    ])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果你想将一个 getter 属性另取一个名字，使用对象形式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...mapGetters(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`</span></span><br><span class=\"line\">  <span class=\"attr\">doneCount</span>: <span class=\"string\">&#x27;doneTodosCount&#x27;</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<br>\n\n<hr>\n<h3 id=\"Mutation\"><a href=\"#Mutation\" class=\"headerlink\" title=\"Mutation\"></a>Mutation</h3><be>\n\n<h4 id=\"Mutation状态更新\"><a href=\"#Mutation状态更新\" class=\"headerlink\" title=\"Mutation状态更新\"></a>Mutation状态更新</h4><p>Vuex的store状态的更新唯一方式：提交Mutation</p>\n<p>🔷Mutation主要包括两部分：</p>\n<p>&emsp;&emsp;🔹 字符串的事件类型（type）</p>\n<p>&emsp;&emsp;🔹 一个回调函数（handler）,该回调函数的第一个参数就是<code>state</code>。</p>\n<p>mutation的定义方式：</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805123705.png\"></p>\n<p>通过mutation更新:</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805123712.png\"></p>\n<br>\n\n<h4 id=\"Mutation传递参数\"><a href=\"#Mutation传递参数\" class=\"headerlink\" title=\"Mutation传递参数\"></a>Mutation传递参数</h4><p>在通过mutation更新数据的时候, 有可能我们希望携带一些<strong>额外的参数</strong></p>\n<p>参数被称为是mutation的载荷(Payload)</p>\n<p>比如我们提这样的一个需求：</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805125539.png\"></p>\n<p>点击按钮 可以+5 和+10.</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805125706.png\"></p>\n<p>设置鼠标点击事件，并将参数，放到commit 的第二个参数的位置。第一个参数是事件类型（type）</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805130005.png\"></p>\n<p>muation 中的代码：</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805130521.png\"></p>\n<hr>\n<p>但是如果参数不止一个 ，这个时候我们就要使用对象的形式来传递    ，也就是payload是一个对象。用的时候在取出需要的信息。</p>\n<p>比如我们添加一个学生的信息。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805132013.png\"></p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805132245.png\"></p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805132401.png\"></p>\n<br>\n\n<h4 id=\"Mutation-的提交风格\"><a href=\"#Mutation-的提交风格\" class=\"headerlink\" title=\"Mutation 的提交风格\"></a>Mutation 的提交风格</h4><p>上面的通过<strong>commit</strong>进行提交是一种普通的方式。</p>\n<p>Vue还提供了另外一种风格, 它是一个包含type属性的对象。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805133804.png\"></p>\n<p>Mutation中的处理方式是将整个commit的对象作为payload使用。</p>\n<p>我们将它打印一下，他就是整个commit的对象</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805133945.png\"></p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805133923.png\"></p>\n<p>所以我们使用的时候 我们将count取出来 就行了，代码没有改变, 依然如下: </p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805134049.png\"></p>\n<br>\n\n<h4 id=\"Mutation响应式规则\"><a href=\"#Mutation响应式规则\" class=\"headerlink\" title=\"Mutation响应式规则\"></a>Mutation响应式规则</h4><p>Vuex的store中的state是响应式的, 当state中的数据发生改变时, Vue组件会自动更新。</p>\n<p>这就要求我们必须遵守一些Vuex对应的规则:</p>\n<p>&emsp;&emsp;<span style=\"color:red\">1、提前在store中初始化好所需的属性.</span></p>\n<p>&emsp;&emsp;2、当给state中的对象添加新属性时, 使用下面的方式:</p>\n<p>&emsp;&emsp;&emsp;&emsp;方式一: 使用Vue.set(obj, ‘newProp’, 123)</p>\n<p>&emsp;&emsp;&emsp;&emsp;方式二: 用新对象给旧对象重新赋值</p>\n<p>我们来看一个例子：</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805143849.png\"></p>\n<p>那我们来对info添加一些属性。比如heigth。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805145123.png\"></p>\n<p>当我们点击按钮的时候，虽然可以添加到state的info中，但是页面没有发生变化，这样添加无法做到响应式。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805145238.png\"></p>\n<p>我们可以使用<code>Vue.set(obj, &#39;newProp&#39;, 123)</code> 的方式。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805145756.png\"></p>\n<p>这样我们当点击按钮的时候，不仅state中的info会发生改变，页面中也会发生响应式的变化。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805150117.png\"></p>\n<br>\n\n<p>这是添加属性，当然删除属性也是一样的。</p>\n<p>我们要做到响应式 还是要使用<code>Vue.delete(state.info,&quot;age&quot;)</code>。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805150834.png\"></p>\n<br>\n\n<h4 id=\"Mutation常量类型\"><a href=\"#Mutation常量类型\" class=\"headerlink\" title=\"Mutation常量类型\"></a>Mutation常量类型</h4><p>🔷 我们来考虑下面的问题:</p>\n<p>&emsp;&emsp;🔹 在mutation中, 我们定义了很多事件类型(也就是其中的方法名称).</p>\n<p>&emsp;&emsp;🔹 当我们的项目增大时, Vuex管理的状态越来越多, 需要更新状态的情况越来越多, 那么意味着Mutation中的方法越来越多.</p>\n<p>&emsp;&emsp;🔹 方法过多, 使用者需要花费大量的经历去记住这些方法, 甚至是多个文件间来回切换, 查看方法名称, 甚至如果不是复制的时候, 可能还会出现写错的情况.</p>\n<br>\n\n<p>🔷 如何避免上述的问题呢?</p>\n<p>&emsp;&emsp;🔹 在各种Flux实现中, 一种很常见的方案就是使用<strong>常量</strong>替代Mutation事件的类型</p>\n<p>&emsp;&emsp;🔹 我们可以将这些常量放在一个单独的文件中, 方便管理以及让整个app所有的事件类型一目了然.</p>\n<br>\n\n<p>🔷 具体怎么做呢?</p>\n<p>&emsp;&emsp;🔹 我们可以创建一个文件: mutation-types.js, 并且在其中定义我们的常量.</p>\n<p>&emsp;&emsp;🔹 定义常量时, 我们可以使用ES2015中的风格, 使用一个常量来作为函数的名称.</p>\n<br>\n\n<p><img src=\"https://qny.aqingya.cn/img/20200805154317.png\"></p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805154343.png\"></p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805154401.png\"></p>\n<br>\n\n<h3 id=\"Action\"><a href=\"#Action\" class=\"headerlink\" title=\"Action\"></a>Action</h3><h4 id=\"Mutation同步函数\"><a href=\"#Mutation同步函数\" class=\"headerlink\" title=\"Mutation同步函数\"></a>Mutation同步函数</h4><p>🔷通常情况下, Vuex要求我们Mutation中的方法必须是同步方法.</p>\n<p>&emsp;&emsp;🔹 主要的原因是当我们使用devtools时, 可以devtools可以帮助我们捕捉mutation的快照.</p>\n<p>&emsp;&emsp;🔹 但是如果是异步操作, 那么devtools将不能很好的追踪这个操作什么时候会被完成.</p>\n<p>举个简单的例子，我们这还是使用setTimeout() 来模拟异步请求。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805160041.png\"></p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805160026.png\"></p>\n<p>当我们点击按钮的时候，3秒时候的确页面发生了修改，但是我们DevTools工具的中的name并没有修改。这是因为我们在Mutation中使用了异步函数。</p>\n<p>这样的话，当我们去用Devtools改bug的时候，就会很蒙，不知道到底哪一个是对的。</p>\n<p>这个时候我们就要使用我们的Action</p>\n<br>\n\n<h4 id=\"Action基本定义\"><a href=\"#Action基本定义\" class=\"headerlink\" title=\"Action基本定义\"></a>Action基本定义</h4><p>🔷我们强调, 不要再Mutation中进行异步操作.</p>\n<p>&emsp;&emsp;🔹 但是某些情况, 我们确实希望在Vuex中进行一些异步操作, 比如网络请求, 必然是异步的. 这个时候怎么处理呢?</p>\n<p>&emsp;&emsp;🔹 Action类似于Mutation, 但是是用来代替Mutation进行异步操作的.</p>\n<p>Action的基本使用代码如下:</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805165816.png\"></p>\n<p><br>当我们提交的时候，这里就不用commit了，就要使用 dispatch。dipatch用于提交Actions，commit用于提交Mutation。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805171504.png\"></p>\n<br>\n\n<h4 id=\"Action参数的传递\"><a href=\"#Action参数的传递\" class=\"headerlink\" title=\"Action参数的传递\"></a>Action参数的传递</h4><p>当然我们也可以携带一些参数，也可以添加一个回调函数，告诉外界我们的异步操作已经完成了。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805171043.png\"></p>\n<br>\n\n<h4 id=\"Action返回的Promise\"><a href=\"#Action返回的Promise\" class=\"headerlink\" title=\"Action返回的Promise\"></a>Action返回的Promise</h4><p>上面回调操作是可以的，但是不够优雅。我们可以使用Promise。Promise经常用于异步操作.</p>\n<p>在Action中, 我们可以将异步操作放在一个Promise中, 并且在成功或者失败后, 调用对应的resolve或reject。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805174501.png\"></p>\n<p>return 一个new Promise 对象的时候。相当于把我们new 的Promise对象，替换了 <code>this.$store.dispatch(&quot;amodify&quot;, &quot;我是modity的参数&quot;)</code> ，在它后面调用then() 方法。就可以继续使用我们的promise了。</p>\n<br>\n\n<h4 id=\"在组件中分发-Action\"><a href=\"#在组件中分发-Action\" class=\"headerlink\" title=\"在组件中分发 Action\"></a>在组件中分发 Action</h4><p>你在组件中使用 <code>this.$store.dispatch(&#39;xxx&#39;)</code> 分发 action，或者使用 <code>mapActions</code> 辅助函数将组件的 methods 映射为 <code>store.dispatch</code> 调用（需要先在根节点注入 <code>store</code>）：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapActions &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vuex&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">    ...mapActions([</span><br><span class=\"line\">      <span class=\"string\">&#x27;increment&#x27;</span>, <span class=\"comment\">// 将 `this.increment()` 映射为 `this.$store.dispatch(&#x27;increment&#x27;)`</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// `mapActions` 也支持载荷：</span></span><br><span class=\"line\">      <span class=\"string\">&#x27;incrementBy&#x27;</span> <span class=\"comment\">// 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch(&#x27;incrementBy&#x27;, amount)`</span></span><br><span class=\"line\">    ]),</span><br><span class=\"line\">    ...mapActions(&#123;</span><br><span class=\"line\">      <span class=\"attr\">add</span>: <span class=\"string\">&#x27;increment&#x27;</span> <span class=\"comment\">// 将 `this.add()` 映射为 `this.$store.dispatch(&#x27;increment&#x27;)`</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<br>\n\n<h4 id=\"组合-Action\"><a href=\"#组合-Action\" class=\"headerlink\" title=\"组合 Action\"></a>组合 Action</h4><p>Action 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？</p>\n<p>首先，你需要明白 <code>store.dispatch</code> 可以处理被触发的 action 的处理函数返回的 Promise，并且 <code>store.dispatch</code> 仍旧返回 Promise：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">actions: &#123;</span><br><span class=\"line\">  actionA (&#123; commit &#125;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        commit(<span class=\"string\">&#x27;someMutation&#x27;</span>)</span><br><span class=\"line\">        resolve()</span><br><span class=\"line\">      &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在你可以：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.dispatch(<span class=\"string\">&#x27;actionA&#x27;</span>).then(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>在另外一个 action 中也可以：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">actions: &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dispatch(<span class=\"string\">&#x27;actionA&#x27;</span>).then(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      commit(<span class=\"string\">&#x27;someOtherMutation&#x27;</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后，如果我们利用 <a href=\"https://tc39.github.io/ecmascript-asyncawait/\">async / await</a>，我们可以如下组合 action：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 假设 getData() 和 getOtherData() 返回的是 Promise</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">actions</span>: &#123;</span><br><span class=\"line\">  <span class=\"keyword\">async</span> actionA (&#123; commit &#125;) &#123;</span><br><span class=\"line\">    commit(<span class=\"string\">&#x27;gotData&#x27;</span>, <span class=\"keyword\">await</span> getData())</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"keyword\">async</span> actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> dispatch(<span class=\"string\">&#x27;actionA&#x27;</span>) <span class=\"comment\">// 等待 actionA 完成</span></span><br><span class=\"line\">    commit(<span class=\"string\">&#x27;gotOtherData&#x27;</span>, <span class=\"keyword\">await</span> getOtherData())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>一个 <code>store.dispatch</code> 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。</p>\n</blockquote>\n<br>\n\n<h3 id=\"Module\"><a href=\"#Module\" class=\"headerlink\" title=\"Module\"></a>Module</h3><br>\n\n<h4 id=\"认识Module\"><a href=\"#认识Module\" class=\"headerlink\" title=\"认识Module\"></a>认识Module</h4><p>🔷Module是模块的意思, 为什么在Vuex中我们要使用模块呢?</p>\n<p>&emsp;&emsp;🔹 Vue使用单一状态树,那么也意味着很多状态都会交给Vuex来管理.</p>\n<p>&emsp;&emsp;🔹 当应用变得非常复杂时,store对象就有可能变得相当臃肿.</p>\n<p>&emsp;&emsp;🔹 为了解决这个问题, Vuex允许我们将store分割成模块(Module), 而每个模块拥有自己的state、mutations、actions、getters等</p>\n<br>\n\n<p>我们按照什么样的方式来组织模块呢? </p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805182102.png\"></p>\n<br>\n\n<h4 id=\"Moudle局部状态\"><a href=\"#Moudle局部状态\" class=\"headerlink\" title=\"Moudle局部状态\"></a>Moudle局部状态</h4><p>上面的代码中, 我们已经有了整体的组织结构, 下面我们来看看具体的局部模块中的代码如何书写.</p>\n<br>\n\n<p>✔  模块中的 state————————————————————————————————–</p>\n<br>\n\n<p>模块中的state是这样定义的：</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805191650.png\"></p>\n<p>那我们怎样使用呐？<code>$store.state.a.name</code></p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805191738.png\"></p>\n<br>\n\n<p>为什么要这么使用<code>$store.state.a.name</code> 呐，这是因为，最终模块a会放在 store中的state中去。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805192023.png\"></p>\n<br>\n\n<p>✔  模块中的 Mutation————————————————————————————————–</p>\n<br>\n\n<p>定义和之前一样：</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805194232.png\"></p>\n<p>在使用的时候，和之前使用的一样，直接commit 就可以了。<code>this.$store.commit(&#39;updateName&#39;, &quot;灰太狼&quot;)</code></p>\n<br>\n\n<p> ✔ 模块中的 Getters————————————————————————————————–</p>\n<br>\n\n<p>基本使用 和之前的一样。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805195748.png\"></p>\n<br>\n\n<p>如果我们想获取到 store （大模块）中的state的数据的话，我们可以这样使用。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805201122.png\"></p>\n<p>在模块中，getters的函数可以有第三个参数，rootState 。它就代表了大模块中的state。</p>\n<br>\n\n<p> ✔  模块中的 Action————————————————————————————————–</p>\n<br>\n\n<p>actions的写法呢? 接收一个context参数对象</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805204221.png\"></p>\n<p>actions 中的 context.commit 不和之前的一样，它仅仅提交的是自己模块中的 mutations。</p>\n<p>我们来看一下 模块a中的context到底是什么。我们来打印一下。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805205448.png\"></p>\n<p>所以，<span style=\"color:red\">局部状态通过 context.state 暴露出来，根节点状态则为 context.rootState，如果getters中也需要使用全局的状态, 可以接受更多的参数。</span></p>\n<br>\n\n<h2 id=\"项目结构\"><a href=\"#项目结构\" class=\"headerlink\" title=\"项目结构\"></a><strong>项目结构</strong></h2><p>当我们的Vuex帮助我们管理过多的内容时, 好的项目结构可以让我们的代码更加清晰.</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805210644.png\"></p>\n<br>\n\n<p>补充：对变量名的管理</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200820095835.png\"></p>\n<p><img src=\"https://qny.aqingya.cn/img/20200820095901.png\"></p>\n<p><img src=\"https://qny.aqingya.cn/img/20200820095953.png\"></p>\n<p><br><br><br><br></p>\n","more":"<h2 id=\"认识VueX\"><a href=\"#认识VueX\" class=\"headerlink\" title=\"认识VueX\"></a>认识VueX</h2><p><a href=\"https://vuex.vuejs.org/zh/\">Vuex官网地址</a></p>\n<h3 id=\"Vuex是做什么的\"><a href=\"#Vuex是做什么的\" class=\"headerlink\" title=\"Vuex是做什么的?\"></a>Vuex是做什么的?</h3><p>🔷 官方解释：Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。</p>\n<p>&emsp;&emsp;🔹 它采用 集中式存储管理 应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>\n<p>&emsp;&emsp;🔹 Vuex 也集成到 Vue 的官方调试工具 <a href=\"https://github.com/vuejs/vue-devtools\">devtools</a><a href=\"https://github.com/vuejs/vue-devtools\"> extension</a>，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。</p>\n<br>\n\n<p><strong>🔷 状态管理</strong>到底是什么？</p>\n<p>&emsp;&emsp;<strong>🔹 状态管理模式、集中式存储管理</strong>这些名词听起来就非常高大上，让人捉摸不透。</p>\n<p>&emsp;&emsp;🔹 其实，你可以简单的将其看成把需要多个组件共享的变量全部存储在一个对象里面。</p>\n<p>&emsp;&emsp;🔹 然后，将这个对象放在顶层的Vue实例中，让其他组件可以使用。</p>\n<p>&emsp;&emsp;🔹 那么，多个组件就可以共享这个对象中的所有变量属性.</p>\n<br>\n\n<p><span style=\"color:red\">Vuex就是为了提供这样一个在多个组件间共享状态的插件，而且是响应式的。</span></p>\n<br>\n\n\n\n<p>🔷 管理什么状态呢 ?</p>\n<p>&emsp;&emsp;🔹 如果你做过大型开放，你一定遇到过多个状态，在多个界面间的共享问题。</p>\n<p>&emsp;&emsp;🔹 比如用户的登录状态、用户名称、头像、地理位置信息等等。</p>\n<p>&emsp;&emsp;🔹 比如商品的收藏、购物车中的物品等等。</p>\n<p>&emsp;&emsp;🔹 这些状态信息，我们都可以放在统一的地方，对它进行保存和管理，而且它们还是响应式的</p>\n<br>\n\n<p>✔ 单页面的状态管理———————————————————————————————</p>\n<br>\n\n<p>我们知道，要在单个组件中进行状态管理是一件非常简单的事情</p>\n<p>什么意思呢？我们来看下面的图片。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200803204415.png\"></p>\n<p>🔷 这图片中的三种东西，怎么理解呢？</p>\n<p>&emsp;&emsp;🔹 State：不用多说，就是我们的状态。（你姑且可以当做就是data中的属性）</p>\n<p>&emsp;&emsp;🔹 View：视图层，可以针对State的变化，显示不同的信息。（这个好理解吧？）</p>\n<p>&emsp;&emsp;🔹 Actions：这里的Actions主要是用户的各种操作：点击、输入等等，会导致状态的改变。</p>\n<br>\n\n<p>举个简单的例子:</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200803204525.png\"></p>\n<p>我们来实现这样的一个简单的小案例。</p>\n<p><img src=\"https://qny.aqingya.cn/img/3262362.png\"></p>\n<p>🔷 在这个案例中，我们有木有状态需要管理呢？没错，就是个数counter。</p>\n<p>🔷 counter需要某种方式被记录下来，也就是我们的State。</p>\n<p>🔷 counter目前的值需要被显示在界面中，也就是我们的View部分。</p>\n<p>🔷 界面发生某些操作时（我们这里是用户的点击，也可以是用户的input），需要去更新状态，也就是我们的Actions</p>\n<p>这不就是上面的流程图了吗？</p>\n<br>\n\n<p>✔ 多状态管理———————————————————————————————</p>\n<br>\n\n\n\n<p>🔷 Vue已经帮我们做好了单个界面的状态管理，但是如果是多个界面呢？</p>\n<p>&emsp;&emsp;🔹 多个试图都依赖同一个状态（一个状态改了，多个界面需要进行更新）</p>\n<p>&emsp;&emsp;🔹 不同界面的Actions都想修改同一个状态（Home.vue需要修改，Profile.vue也需要修改这个状态）</p>\n<p>🔷 也就是说对于某些状态(状态1/状态2/状态3)来说只属于我们某一个试图，但是也有一些状态(状态a/状态b/状态c)属于多个试图共同想要维护的。</p>\n<p>&emsp;&emsp;🔹 状态1/状态2/状态3你放在自己的房间中，你自己管理自己用，没问题。</p>\n<p>&emsp;&emsp;🔹 但是状态a/状态b/状态c我们希望交给一个大管家来统一帮助我们管理！！！</p>\n<p>&emsp;&emsp;🔹 没错，Vuex就是为我们提供这个大管家的工具。</p>\n<p>🔷 全局单例模式（大管家）</p>\n<p>&emsp;&emsp;🔹 我们现在要做的就是将共享的状态抽取出来，交给我们的大管家，统一进行管理。</p>\n<p>&emsp;&emsp;🔹 之后，你们每个试图，按照我<strong>规定好的</strong>规定，进行访问和修改等操作。</p>\n<p>这就是Vuex背后的基本思想。</p>\n<br>\n\n<p>✔ Vuex状态管理图例—————————-</p>\n<br>\n\n<p>当我们去修改Vuex 中的 State的时候，我们不应该直接去修改 State ，而是通过 Actions、Mutations 进而来修改State。</p>\n<p>Devtools：它是Vue开发的一个浏览器插件，通过Mutations，它可以记录我们每一次修改State。</p>\n<p>Actions：如果我们请求是异步操作的话，我们会通过Actions，将异步转化为同步，因为Devtools通过Mutations来监听我们对 State 的修改只能是同步操作。如果请求是同步的话，我们可以绕过Actions。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200803210504.png\"></p>\n<br>\n\n<h2 id=\"Vuex插件的安装\"><a href=\"#Vuex插件的安装\" class=\"headerlink\" title=\"Vuex插件的安装\"></a>Vuex插件的安装</h2><p>安装生产时依赖：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cnpm install vuex --save</span><br></pre></td></tr></table></figure>\n\n<be>\n\n\n\n<h2 id=\"Vuex-基本使用\"><a href=\"#Vuex-基本使用\" class=\"headerlink\" title=\"Vuex 基本使用\"></a>Vuex 基本使用</h2><p>我们还是实现一下之前简单的案例</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200803221526.png\"></p>\n<p>🔷 首先，我们需要在某个地方存放我们的Vuex代码：</p>\n<p>  &emsp;&emsp; 🔹 这里，我们先创建一个文件夹store，并且在其中创建一个index.js文件</p>\n<p>&emsp;&emsp;   🔹 在index.js文件中写入如下代码：</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200803222114.png\"></p>\n<br>\n\n<p><strong>✔ 挂载到</strong>Vue实例中</p>\n<p>🔷其次，我们让所有的Vue组件都可以使用这个store对象</p>\n<p>&emsp;&emsp;  🔹 来到main.js文件，导入store对象，并且放在new Vue中</p>\n<p>&emsp;&emsp;  🔹 这样，在其他Vue组件中，我们就可以通过this.$store的方式，获取到这个store对象了</p>\n<p>挂载到Vue实例中 相当于执行 <code>Vue.prototype.$store = store</code> ，将store对象放置在new Vue对象中，这样可以保证在所有的组件中都可以使用到。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200803222301.png\"></p>\n<br>\n\n<p>✔ 使用Vuex</p>\n<p><img src=\"https://qny.aqingya.cn/img/image-20200803222537327.png\"></p>\n<br>\n\n<p>🔷我们来对使用步骤，做一个简单的小节：</p>\n<p>&emsp;&emsp;🔹  1.提取出一个公共的store对象，用于保存在多个组件中共享的状态。</p>\n<p>&emsp;&emsp;🔹  2.将store对象放置在new Vue对象中，这样可以保证在所有的组件中都可以使用到</p>\n<p>&emsp;&emsp;🔹  3.在其他组件中使用store对象中保存的状态即可</p>\n<p>&emsp;&emsp;&emsp;&emsp; 通过<code>this.$store.state</code>.属性的方式来访问状态</p>\n<p>&emsp;&emsp;&emsp;&emsp; 通过<code>this.$store.commit(&#39;mutation中方法&#39;)</code>来修改状态</p>\n<br>\n\n<p>🔷注意事项：</p>\n<p>&emsp;&emsp;🔹 我们是通过提交mutation的方式，而非直接改变store.state.count。</p>\n<p>&emsp;&emsp;🔹 这是因为Vuex可以更明确的追踪状态的变化，所以不要直接改变store.state.count的值。</p>\n<br>\n\n<p>所以 可以通过浏览器插件Devtools来跟踪 state 的状态。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200803223121.png\"></p>\n<br>\n\n<h2 id=\"Vuex核心概念\"><a href=\"#Vuex核心概念\" class=\"headerlink\" title=\"Vuex核心概念\"></a>Vuex核心概念</h2><br>\n\n<h3 id=\"State\"><a href=\"#State\" class=\"headerlink\" title=\"State\"></a>State</h3><p>🔷Vuex提出使用单一状态树, 什么是单一状态树呢？</p>\n<p>&emsp;&emsp;🔹 英文名称是Single Source of Truth，也可以翻译成单一数据源。</p>\n<p>🔷但是，它是什么呢？我们来看一个生活中的例子。</p>\n<p>&emsp;&emsp;🔹 OK，我用一个生活中的例子做一个简单的类比。</p>\n<p>&emsp;&emsp;🔹 我们知道，在国内我们有很多的信息需要被记录，比如上学时的个人档案，工作后的社保记录，公积金记录，结婚后的婚姻信息，以及其他相关的户口、医疗、文凭、房产记录等等（还有很多信息）。</p>\n<p>&emsp;&emsp;🔹 这些信息被分散在很多地方进行管理，有一天你需要办某个业务时(比如入户某个城市)，你会发现你需要到各个对应的工作地点去打印、盖章各种资料信息，最后到一个地方提交证明你的信息无误。</p>\n<p>&emsp;&emsp;🔹 这种保存信息的方案，不仅仅低效，而且不方便管理，以及日后的维护也是一个庞大的工作(需要大量的各个部门的人力来维护，当然国家目前已经在完善我们的这个系统了)。</p>\n<br>\n\n<p>🔷这个和我们在应用开发中比较类似：</p>\n<p>&emsp;&emsp;🔹 如果你的状态信息是保存到多个Store对象中的，那么之后的管理和维护等等都会变得特别困难。</p>\n<p>&emsp;&emsp;🔹 <span style=\"color:red\">所以Vuex也使用了单一状态树来管理应用层级的全部状态。</span></p>\n<p>&emsp;&emsp;🔹 <span style=\"color:red\">单一状态树能够让我们最直接的方式找到某个状态的片段，而且在之后的维护和调试过程中，也可以非常方便的管理和维护。</span></p>\n<br>\n\n\n\n<h3 id=\"Getters\"><a href=\"#Getters\" class=\"headerlink\" title=\"Getters\"></a>Getters</h3><p>有时候，我们需要从Stare中获取的一些经过改变的数据，我们就可以使用Getters。这比较类似于<a href=\"https://aqingya.cn/articl/3a0cc30e.html#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7-computed\">计算属性</a>。</p>\n<p>Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p>\n<p>举个简单的例子：在State中有一个数组，包含一些学生的基本信息。我们需要拿到age 大于18 的学生的信息，我们就可以使用Getters。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805105113.png\"></p>\n<br>\n\n<p>使用getters  <code>&lt;h2&gt;&#123;&#123;$store.getters.more18age&#125;&#125;&lt;/h2&gt;</code></p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805105441.png\"></p>\n<p>就获取到了age 大于18 的学生信息。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805105503.png\"></p>\n<hr>\n<p><br>要是放在以前，我们可能会使用computed属性。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805110256.png\"></p>\n<p>但是也有一个缺点，比如我们想要在多个组件中都同样的数据变换，那么我们都在在各种的组件中设置同样的computed，这样很不好。我们就可以使用vuex里的gitters属性。</p>\n<br>\n\n<hr>\n<br>\n\n<p>我们在提一个需求：要得到年纪大于18 的学生的人数。我们就可以这样来做。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805111557.png\"></p>\n<p>使用该函数：<code>$store.getters.more18ageLength</code></p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805111642.png\"></p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805111715.png\"></p>\n<br>\n\n<p>我们再来看一个需求，我们不要把age写死，而是当做参数传递进来。</p>\n<p>首先我们想到 的是直接在moreage中传递参数，但是这样是不行的，我们可以return 一个函数，在这个函数中传入参数，这样我们在使用的时候就可以，<code>$store.getters.moreage(20)</code> 。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805112206.png\"></p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805112235.png\"></p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805112425.png\"></p>\n<br>\n\n<p>总结：</p>\n<p><span style=\"color:red\">🔹 如果我们没有传递参数的时候，我们就可以在getters中直接定义一个函数。</span></p>\n<p><span style=\"color:red\">🔹 如果我们需要使用我们在getters中定义过的属性，我们就可以在定义函数的时候，将getters做为第二个参数传递进去。</span></p>\n<p><span style=\"color:red\">🔹 如果我们需要在函数中传递参数，只能让getters本身返回另一个函数。参数定义在这个函数中，在使用是时候就可以传递参数了。</span></p>\n<br>\n\n<hr>\n<h4 id=\"通过属性访问\"><a href=\"#通过属性访问\" class=\"headerlink\" title=\"通过属性访问\"></a>通过属性访问</h4><p>Getter 会暴露为 <code>store.getters</code> 对象，你可以以属性的形式访问这些值：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.getters.doneTodos <span class=\"comment\">// -&gt; [&#123; id: 1, text: &#x27;...&#x27;, done: true &#125;]</span></span><br></pre></td></tr></table></figure>\n\n<p>Getter 也可以接受其他 getter 作为第二个参数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getters: &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"attr\">doneTodosCount</span>: <span class=\"function\">(<span class=\"params\">state, getters</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getters.doneTodos.length</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">store.getters.doneTodosCount <span class=\"comment\">// -&gt; 1</span></span><br></pre></td></tr></table></figure>\n\n<p>我们可以很容易地在任何组件中使用它：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: &#123;</span><br><span class=\"line\">  doneTodosCount () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.$store.getters.doneTodosCount</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意，getter 在通过属性访问时是作为 Vue 的响应式系统的一部分缓存其中的。</p>\n<br>\n\n<h4 id=\"通过方法访问\"><a href=\"#通过方法访问\" class=\"headerlink\" title=\"通过方法访问\"></a>通过方法访问</h4><p>你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getters: &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"attr\">getTodoById</span>: <span class=\"function\">(<span class=\"params\">state</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">id</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> state.todos.find(<span class=\"function\"><span class=\"params\">todo</span> =&gt;</span> todo.id === id)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">store.getters.getTodoById(<span class=\"number\">2</span>) <span class=\"comment\">// -&gt; &#123; id: 2, text: &#x27;...&#x27;, done: false &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>注意，getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。</p>\n<br>\n\n<h4 id=\"mapGetters-辅助函数\"><a href=\"#mapGetters-辅助函数\" class=\"headerlink\" title=\"mapGetters 辅助函数\"></a><code>mapGetters</code> 辅助函数</h4><p><code>mapGetters</code> 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapGetters &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vuex&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"attr\">computed</span>: &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 使用对象展开运算符将 getter 混入 computed 对象中</span></span><br><span class=\"line\">    ...mapGetters([</span><br><span class=\"line\">      <span class=\"string\">&#x27;doneTodosCount&#x27;</span>,</span><br><span class=\"line\">      <span class=\"string\">&#x27;anotherGetter&#x27;</span>,</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    ])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果你想将一个 getter 属性另取一个名字，使用对象形式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...mapGetters(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`</span></span><br><span class=\"line\">  <span class=\"attr\">doneCount</span>: <span class=\"string\">&#x27;doneTodosCount&#x27;</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<br>\n\n<hr>\n<h3 id=\"Mutation\"><a href=\"#Mutation\" class=\"headerlink\" title=\"Mutation\"></a>Mutation</h3><be>\n\n<h4 id=\"Mutation状态更新\"><a href=\"#Mutation状态更新\" class=\"headerlink\" title=\"Mutation状态更新\"></a>Mutation状态更新</h4><p>Vuex的store状态的更新唯一方式：提交Mutation</p>\n<p>🔷Mutation主要包括两部分：</p>\n<p>&emsp;&emsp;🔹 字符串的事件类型（type）</p>\n<p>&emsp;&emsp;🔹 一个回调函数（handler）,该回调函数的第一个参数就是<code>state</code>。</p>\n<p>mutation的定义方式：</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805123705.png\"></p>\n<p>通过mutation更新:</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805123712.png\"></p>\n<br>\n\n<h4 id=\"Mutation传递参数\"><a href=\"#Mutation传递参数\" class=\"headerlink\" title=\"Mutation传递参数\"></a>Mutation传递参数</h4><p>在通过mutation更新数据的时候, 有可能我们希望携带一些<strong>额外的参数</strong></p>\n<p>参数被称为是mutation的载荷(Payload)</p>\n<p>比如我们提这样的一个需求：</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805125539.png\"></p>\n<p>点击按钮 可以+5 和+10.</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805125706.png\"></p>\n<p>设置鼠标点击事件，并将参数，放到commit 的第二个参数的位置。第一个参数是事件类型（type）</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805130005.png\"></p>\n<p>muation 中的代码：</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805130521.png\"></p>\n<hr>\n<p>但是如果参数不止一个 ，这个时候我们就要使用对象的形式来传递    ，也就是payload是一个对象。用的时候在取出需要的信息。</p>\n<p>比如我们添加一个学生的信息。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805132013.png\"></p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805132245.png\"></p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805132401.png\"></p>\n<br>\n\n<h4 id=\"Mutation-的提交风格\"><a href=\"#Mutation-的提交风格\" class=\"headerlink\" title=\"Mutation 的提交风格\"></a>Mutation 的提交风格</h4><p>上面的通过<strong>commit</strong>进行提交是一种普通的方式。</p>\n<p>Vue还提供了另外一种风格, 它是一个包含type属性的对象。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805133804.png\"></p>\n<p>Mutation中的处理方式是将整个commit的对象作为payload使用。</p>\n<p>我们将它打印一下，他就是整个commit的对象</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805133945.png\"></p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805133923.png\"></p>\n<p>所以我们使用的时候 我们将count取出来 就行了，代码没有改变, 依然如下: </p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805134049.png\"></p>\n<br>\n\n<h4 id=\"Mutation响应式规则\"><a href=\"#Mutation响应式规则\" class=\"headerlink\" title=\"Mutation响应式规则\"></a>Mutation响应式规则</h4><p>Vuex的store中的state是响应式的, 当state中的数据发生改变时, Vue组件会自动更新。</p>\n<p>这就要求我们必须遵守一些Vuex对应的规则:</p>\n<p>&emsp;&emsp;<span style=\"color:red\">1、提前在store中初始化好所需的属性.</span></p>\n<p>&emsp;&emsp;2、当给state中的对象添加新属性时, 使用下面的方式:</p>\n<p>&emsp;&emsp;&emsp;&emsp;方式一: 使用Vue.set(obj, ‘newProp’, 123)</p>\n<p>&emsp;&emsp;&emsp;&emsp;方式二: 用新对象给旧对象重新赋值</p>\n<p>我们来看一个例子：</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805143849.png\"></p>\n<p>那我们来对info添加一些属性。比如heigth。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805145123.png\"></p>\n<p>当我们点击按钮的时候，虽然可以添加到state的info中，但是页面没有发生变化，这样添加无法做到响应式。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805145238.png\"></p>\n<p>我们可以使用<code>Vue.set(obj, &#39;newProp&#39;, 123)</code> 的方式。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805145756.png\"></p>\n<p>这样我们当点击按钮的时候，不仅state中的info会发生改变，页面中也会发生响应式的变化。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805150117.png\"></p>\n<br>\n\n<p>这是添加属性，当然删除属性也是一样的。</p>\n<p>我们要做到响应式 还是要使用<code>Vue.delete(state.info,&quot;age&quot;)</code>。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805150834.png\"></p>\n<br>\n\n<h4 id=\"Mutation常量类型\"><a href=\"#Mutation常量类型\" class=\"headerlink\" title=\"Mutation常量类型\"></a>Mutation常量类型</h4><p>🔷 我们来考虑下面的问题:</p>\n<p>&emsp;&emsp;🔹 在mutation中, 我们定义了很多事件类型(也就是其中的方法名称).</p>\n<p>&emsp;&emsp;🔹 当我们的项目增大时, Vuex管理的状态越来越多, 需要更新状态的情况越来越多, 那么意味着Mutation中的方法越来越多.</p>\n<p>&emsp;&emsp;🔹 方法过多, 使用者需要花费大量的经历去记住这些方法, 甚至是多个文件间来回切换, 查看方法名称, 甚至如果不是复制的时候, 可能还会出现写错的情况.</p>\n<br>\n\n<p>🔷 如何避免上述的问题呢?</p>\n<p>&emsp;&emsp;🔹 在各种Flux实现中, 一种很常见的方案就是使用<strong>常量</strong>替代Mutation事件的类型</p>\n<p>&emsp;&emsp;🔹 我们可以将这些常量放在一个单独的文件中, 方便管理以及让整个app所有的事件类型一目了然.</p>\n<br>\n\n<p>🔷 具体怎么做呢?</p>\n<p>&emsp;&emsp;🔹 我们可以创建一个文件: mutation-types.js, 并且在其中定义我们的常量.</p>\n<p>&emsp;&emsp;🔹 定义常量时, 我们可以使用ES2015中的风格, 使用一个常量来作为函数的名称.</p>\n<br>\n\n<p><img src=\"https://qny.aqingya.cn/img/20200805154317.png\"></p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805154343.png\"></p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805154401.png\"></p>\n<br>\n\n<h3 id=\"Action\"><a href=\"#Action\" class=\"headerlink\" title=\"Action\"></a>Action</h3><h4 id=\"Mutation同步函数\"><a href=\"#Mutation同步函数\" class=\"headerlink\" title=\"Mutation同步函数\"></a>Mutation同步函数</h4><p>🔷通常情况下, Vuex要求我们Mutation中的方法必须是同步方法.</p>\n<p>&emsp;&emsp;🔹 主要的原因是当我们使用devtools时, 可以devtools可以帮助我们捕捉mutation的快照.</p>\n<p>&emsp;&emsp;🔹 但是如果是异步操作, 那么devtools将不能很好的追踪这个操作什么时候会被完成.</p>\n<p>举个简单的例子，我们这还是使用setTimeout() 来模拟异步请求。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805160041.png\"></p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805160026.png\"></p>\n<p>当我们点击按钮的时候，3秒时候的确页面发生了修改，但是我们DevTools工具的中的name并没有修改。这是因为我们在Mutation中使用了异步函数。</p>\n<p>这样的话，当我们去用Devtools改bug的时候，就会很蒙，不知道到底哪一个是对的。</p>\n<p>这个时候我们就要使用我们的Action</p>\n<br>\n\n<h4 id=\"Action基本定义\"><a href=\"#Action基本定义\" class=\"headerlink\" title=\"Action基本定义\"></a>Action基本定义</h4><p>🔷我们强调, 不要再Mutation中进行异步操作.</p>\n<p>&emsp;&emsp;🔹 但是某些情况, 我们确实希望在Vuex中进行一些异步操作, 比如网络请求, 必然是异步的. 这个时候怎么处理呢?</p>\n<p>&emsp;&emsp;🔹 Action类似于Mutation, 但是是用来代替Mutation进行异步操作的.</p>\n<p>Action的基本使用代码如下:</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805165816.png\"></p>\n<p><br>当我们提交的时候，这里就不用commit了，就要使用 dispatch。dipatch用于提交Actions，commit用于提交Mutation。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805171504.png\"></p>\n<br>\n\n<h4 id=\"Action参数的传递\"><a href=\"#Action参数的传递\" class=\"headerlink\" title=\"Action参数的传递\"></a>Action参数的传递</h4><p>当然我们也可以携带一些参数，也可以添加一个回调函数，告诉外界我们的异步操作已经完成了。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805171043.png\"></p>\n<br>\n\n<h4 id=\"Action返回的Promise\"><a href=\"#Action返回的Promise\" class=\"headerlink\" title=\"Action返回的Promise\"></a>Action返回的Promise</h4><p>上面回调操作是可以的，但是不够优雅。我们可以使用Promise。Promise经常用于异步操作.</p>\n<p>在Action中, 我们可以将异步操作放在一个Promise中, 并且在成功或者失败后, 调用对应的resolve或reject。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805174501.png\"></p>\n<p>return 一个new Promise 对象的时候。相当于把我们new 的Promise对象，替换了 <code>this.$store.dispatch(&quot;amodify&quot;, &quot;我是modity的参数&quot;)</code> ，在它后面调用then() 方法。就可以继续使用我们的promise了。</p>\n<br>\n\n<h4 id=\"在组件中分发-Action\"><a href=\"#在组件中分发-Action\" class=\"headerlink\" title=\"在组件中分发 Action\"></a>在组件中分发 Action</h4><p>你在组件中使用 <code>this.$store.dispatch(&#39;xxx&#39;)</code> 分发 action，或者使用 <code>mapActions</code> 辅助函数将组件的 methods 映射为 <code>store.dispatch</code> 调用（需要先在根节点注入 <code>store</code>）：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapActions &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vuex&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">    ...mapActions([</span><br><span class=\"line\">      <span class=\"string\">&#x27;increment&#x27;</span>, <span class=\"comment\">// 将 `this.increment()` 映射为 `this.$store.dispatch(&#x27;increment&#x27;)`</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// `mapActions` 也支持载荷：</span></span><br><span class=\"line\">      <span class=\"string\">&#x27;incrementBy&#x27;</span> <span class=\"comment\">// 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch(&#x27;incrementBy&#x27;, amount)`</span></span><br><span class=\"line\">    ]),</span><br><span class=\"line\">    ...mapActions(&#123;</span><br><span class=\"line\">      <span class=\"attr\">add</span>: <span class=\"string\">&#x27;increment&#x27;</span> <span class=\"comment\">// 将 `this.add()` 映射为 `this.$store.dispatch(&#x27;increment&#x27;)`</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<br>\n\n<h4 id=\"组合-Action\"><a href=\"#组合-Action\" class=\"headerlink\" title=\"组合 Action\"></a>组合 Action</h4><p>Action 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？</p>\n<p>首先，你需要明白 <code>store.dispatch</code> 可以处理被触发的 action 的处理函数返回的 Promise，并且 <code>store.dispatch</code> 仍旧返回 Promise：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">actions: &#123;</span><br><span class=\"line\">  actionA (&#123; commit &#125;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        commit(<span class=\"string\">&#x27;someMutation&#x27;</span>)</span><br><span class=\"line\">        resolve()</span><br><span class=\"line\">      &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在你可以：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.dispatch(<span class=\"string\">&#x27;actionA&#x27;</span>).then(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>在另外一个 action 中也可以：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">actions: &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dispatch(<span class=\"string\">&#x27;actionA&#x27;</span>).then(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      commit(<span class=\"string\">&#x27;someOtherMutation&#x27;</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后，如果我们利用 <a href=\"https://tc39.github.io/ecmascript-asyncawait/\">async / await</a>，我们可以如下组合 action：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 假设 getData() 和 getOtherData() 返回的是 Promise</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">actions</span>: &#123;</span><br><span class=\"line\">  <span class=\"keyword\">async</span> actionA (&#123; commit &#125;) &#123;</span><br><span class=\"line\">    commit(<span class=\"string\">&#x27;gotData&#x27;</span>, <span class=\"keyword\">await</span> getData())</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"keyword\">async</span> actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> dispatch(<span class=\"string\">&#x27;actionA&#x27;</span>) <span class=\"comment\">// 等待 actionA 完成</span></span><br><span class=\"line\">    commit(<span class=\"string\">&#x27;gotOtherData&#x27;</span>, <span class=\"keyword\">await</span> getOtherData())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>一个 <code>store.dispatch</code> 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。</p>\n</blockquote>\n<br>\n\n<h3 id=\"Module\"><a href=\"#Module\" class=\"headerlink\" title=\"Module\"></a>Module</h3><br>\n\n<h4 id=\"认识Module\"><a href=\"#认识Module\" class=\"headerlink\" title=\"认识Module\"></a>认识Module</h4><p>🔷Module是模块的意思, 为什么在Vuex中我们要使用模块呢?</p>\n<p>&emsp;&emsp;🔹 Vue使用单一状态树,那么也意味着很多状态都会交给Vuex来管理.</p>\n<p>&emsp;&emsp;🔹 当应用变得非常复杂时,store对象就有可能变得相当臃肿.</p>\n<p>&emsp;&emsp;🔹 为了解决这个问题, Vuex允许我们将store分割成模块(Module), 而每个模块拥有自己的state、mutations、actions、getters等</p>\n<br>\n\n<p>我们按照什么样的方式来组织模块呢? </p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805182102.png\"></p>\n<br>\n\n<h4 id=\"Moudle局部状态\"><a href=\"#Moudle局部状态\" class=\"headerlink\" title=\"Moudle局部状态\"></a>Moudle局部状态</h4><p>上面的代码中, 我们已经有了整体的组织结构, 下面我们来看看具体的局部模块中的代码如何书写.</p>\n<br>\n\n<p>✔  模块中的 state————————————————————————————————–</p>\n<br>\n\n<p>模块中的state是这样定义的：</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805191650.png\"></p>\n<p>那我们怎样使用呐？<code>$store.state.a.name</code></p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805191738.png\"></p>\n<br>\n\n<p>为什么要这么使用<code>$store.state.a.name</code> 呐，这是因为，最终模块a会放在 store中的state中去。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805192023.png\"></p>\n<br>\n\n<p>✔  模块中的 Mutation————————————————————————————————–</p>\n<br>\n\n<p>定义和之前一样：</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805194232.png\"></p>\n<p>在使用的时候，和之前使用的一样，直接commit 就可以了。<code>this.$store.commit(&#39;updateName&#39;, &quot;灰太狼&quot;)</code></p>\n<br>\n\n<p> ✔ 模块中的 Getters————————————————————————————————–</p>\n<br>\n\n<p>基本使用 和之前的一样。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805195748.png\"></p>\n<br>\n\n<p>如果我们想获取到 store （大模块）中的state的数据的话，我们可以这样使用。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805201122.png\"></p>\n<p>在模块中，getters的函数可以有第三个参数，rootState 。它就代表了大模块中的state。</p>\n<br>\n\n<p> ✔  模块中的 Action————————————————————————————————–</p>\n<br>\n\n<p>actions的写法呢? 接收一个context参数对象</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805204221.png\"></p>\n<p>actions 中的 context.commit 不和之前的一样，它仅仅提交的是自己模块中的 mutations。</p>\n<p>我们来看一下 模块a中的context到底是什么。我们来打印一下。</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805205448.png\"></p>\n<p>所以，<span style=\"color:red\">局部状态通过 context.state 暴露出来，根节点状态则为 context.rootState，如果getters中也需要使用全局的状态, 可以接受更多的参数。</span></p>\n<br>\n\n<h2 id=\"项目结构\"><a href=\"#项目结构\" class=\"headerlink\" title=\"项目结构\"></a><strong>项目结构</strong></h2><p>当我们的Vuex帮助我们管理过多的内容时, 好的项目结构可以让我们的代码更加清晰.</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200805210644.png\"></p>\n<br>\n\n<p>补充：对变量名的管理</p>\n<p><img src=\"https://qny.aqingya.cn/img/20200820095835.png\"></p>\n<p><img src=\"https://qny.aqingya.cn/img/20200820095901.png\"></p>\n<p><img src=\"https://qny.aqingya.cn/img/20200820095953.png\"></p>\n<p><br><br><br><br></p>","categories":[{"name":"Vue","path":"api/categories/Vue.json"}],"tags":[{"name":"Vue","path":"api/tags/Vue.json"},{"name":"VueX","path":"api/tags/VueX.json"}]}