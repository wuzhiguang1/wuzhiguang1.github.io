{"title":"ES6箭头函数与普通函数的区别","slug":"49","date":"2020-07-08T09:10:57.000Z","updated":"2022-07-29T04:22:04.778Z","comments":true,"path":"api/articles/49.json","excerpt":" [Figure] ","covers":["https://qny.aqingya.cn/img/1732ee021d2e3247.png"],"content":"<p><img src=\"https://qny.aqingya.cn/img/1732ee021d2e3247.png\"></p>\n<span id=\"more\"></span>\n\n<h1 id=\"ES6箭头函数与普通函数的区别\"><a href=\"#ES6箭头函数与普通函数的区别\" class=\"headerlink\" title=\"ES6箭头函数与普通函数的区别\"></a>ES6箭头函数与普通函数的区别</h1><h2 id=\"ES6箭头函数与普通函数的区别-1\"><a href=\"#ES6箭头函数与普通函数的区别-1\" class=\"headerlink\" title=\"ES6箭头函数与普通函数的区别\"></a>ES6箭头函数与普通函数的区别</h2><p>普通函数中的<code>this</code>指向函数被调用的对象，因此对于不同的调用者，<code>this</code>的值是不同的。而箭头函数中并没有自己的<code>this</code>（同时，箭头函数中也没有其他的局部变量，如this，argument，super等），所以箭头函数中的<code>this</code>是固定的，它指向定义该函数时所在的对象。</p>\n<h2 id=\"普通函数\"><a href=\"#普通函数\" class=\"headerlink\" title=\"普通函数\"></a>普通函数</h2><p>下面我们举一个简单的例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a  = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span> : <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">foo</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.foo(); <span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = obj;</span><br><span class=\"line\">bar.a = <span class=\"number\">2</span>;</span><br><span class=\"line\">bar.foo(); <span class=\"comment\">//2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> baz = obj.foo;</span><br><span class=\"line\">baz(); <span class=\"comment\">//3</span></span><br></pre></td></tr></table></figure>\n<p>上述代码中，出现了三种情况：</p>\n<p>1 、直接通过obj调用其中的方法<code>foo</code>，此时，<code>this</code>就会指向调用foo函数的对象，也就是obj;<br>2 、将obj对象赋给一个新的对象bar，此时通过bar调用foo函数，<code>this</code>的值就会指向调用者bar；<br>3 、将obj.foo赋给一个新对象baz，通过baz()调用foo函数，此时的this指向window；</p>\n<p>由此我们可以得出结论：</p>\n<p>1、普通函数的this总是指向它的直接调用者。<br>2、在严格模式下，没找到直接调用者，则函数中的<code>this</code>是<code>undefined</code>。<br>3、在默认模式下（非严格模式），没找到直接调用者，则函数中的<code>this</code>指向<code>window</code>。</p>\n<p>再考虑一下下面的情况：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span> : <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">foo</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.a),<span class=\"number\">3000</span>&#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.foo(); <span class=\"comment\">//undefined</span></span><br></pre></td></tr></table></figure>\n<p>你可能会认为此时的输出应该为1，但是结果却是<code>undefined</code>。因为此时this的指向是全局的<code>window</code>对象。<br>通过以上例子，可以得出以下总结：</p>\n<p>1、对于方法（即通过对象调用了该函数），普通函数中的<code>this</code>总是指向它的调用者。<br>2、对于一般函数，this指向全局变量（非严格模式下）或者<code>undefined</code>（严格模式下）。在上例中setTimeout中的function未被任何对象调用，因此它的<code>this</code>指向还是<code>window</code>对象。因此，这也可以总结成：javascript 的<code>this</code>可以简单的认为是后期绑定，没有地方绑定的时候，默认绑定<code>window</code>或<code>undefined</code>。</p>\n<p>如果我们希望可以在上例的setTimeout函数中使用<code>this</code>要怎么做呢？在箭头函数出现之前，我们往往会使用以下两种方法：</p>\n<p>1、在setTimeout函数的外部，也就是上层函数<code>foo</code>内部通过将<code>this</code>值赋给一个临时变量来实现。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span> : <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">foo</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> that  = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"built_in\">console</span>.log(that.a),<span class=\"number\">3000</span>&#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.foo(); <span class=\"comment\">//1</span></span><br></pre></td></tr></table></figure>\n<p>2、通过<code>bind()</code>来绑定<code>this</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span> : <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">foo</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.a),<span class=\"number\">3000</span>&#125;.bind(<span class=\"built_in\">this</span>))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.foo(); <span class=\"comment\">//1</span></span><br></pre></td></tr></table></figure>\n<p>这种现象在ES6引入箭头函数后得到了改善。</p>\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><p>箭头函数是ES6中引入的新特性，使用方法为：</p>\n<p>其中()内是要带入的参数，{}内是要执行的语句。箭头函数是函数式编程的一种体现，函数式编程将更多的关注点放在输入和输出的关系，省去了过程的一些因素，因此箭头函数中没有自己的<code>this</code>，<code>arguments</code>，<code>new target（ES6）</code>和 <code>super(ES6)</code>。箭头函数相当于匿名函数，因此不能使用<code>new</code>来作为构造函数使用。</p>\n<p>箭头函数中的this始终指向其父级作用域中的<code>this</code>。换句话说，箭头函数会捕获其所在的上下文的<code>this</code>值，作为自己的<code>this</code>值。任何方法都改变不了其指向，如<code>call(), bind(), apply()</code>。在箭头函数中调用 <code>this</code>时，仅仅是简单的沿着作用域链向上寻找，找到最近的一个 this 拿来使用，它与调用时的上下文无关。我们用代码来解释一下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">10</span>,</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.a); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>); <span class=\"comment\">// Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …&#125;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">c</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.a); <span class=\"comment\">// 10</span></span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>); <span class=\"comment\">// &#123;a: 10, b: ƒ, c: ƒ&#125;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">d</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.a); <span class=\"comment\">// 10</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">e</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      setTime</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  obj.b(); </span><br><span class=\"line\">  obj.c();</span><br><span class=\"line\">  obj.d()();</span><br></pre></td></tr></table></figure>\n<p>简单分析一下代码，obj.b（）中的<code>this</code>会继承父级上下文中的<code>this</code>值，也就是与obj有相同的<code>this</code>指向，为全局变量<code>window</code>。obj.c()的<code>this</code>指向即为调用者obj，obj.d().()中的<code>this</code>也继承自父级上下文中的<code>this</code>，即d的<code>this</code>指向，也就是obj。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><strong>箭头函数没有自己的<code>this</code>，箭头函数的<code>this </code>不是调用的时候决定的，而是在定义的时候处在的对象就是它的<code>this</code>。<br>箭头函数的<code>this</code>看外层是否有函数，如果有，外层函数的<code>this</code>就是内部箭头函数的<code>this</code>，如果没有，则<code>this</code>，是<code>window</code>。</strong></p>\n","more":"<h1 id=\"ES6箭头函数与普通函数的区别\"><a href=\"#ES6箭头函数与普通函数的区别\" class=\"headerlink\" title=\"ES6箭头函数与普通函数的区别\"></a>ES6箭头函数与普通函数的区别</h1><h2 id=\"ES6箭头函数与普通函数的区别-1\"><a href=\"#ES6箭头函数与普通函数的区别-1\" class=\"headerlink\" title=\"ES6箭头函数与普通函数的区别\"></a>ES6箭头函数与普通函数的区别</h2><p>普通函数中的<code>this</code>指向函数被调用的对象，因此对于不同的调用者，<code>this</code>的值是不同的。而箭头函数中并没有自己的<code>this</code>（同时，箭头函数中也没有其他的局部变量，如this，argument，super等），所以箭头函数中的<code>this</code>是固定的，它指向定义该函数时所在的对象。</p>\n<h2 id=\"普通函数\"><a href=\"#普通函数\" class=\"headerlink\" title=\"普通函数\"></a>普通函数</h2><p>下面我们举一个简单的例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a  = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span> : <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">foo</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.foo(); <span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = obj;</span><br><span class=\"line\">bar.a = <span class=\"number\">2</span>;</span><br><span class=\"line\">bar.foo(); <span class=\"comment\">//2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> baz = obj.foo;</span><br><span class=\"line\">baz(); <span class=\"comment\">//3</span></span><br></pre></td></tr></table></figure>\n<p>上述代码中，出现了三种情况：</p>\n<p>1 、直接通过obj调用其中的方法<code>foo</code>，此时，<code>this</code>就会指向调用foo函数的对象，也就是obj;<br>2 、将obj对象赋给一个新的对象bar，此时通过bar调用foo函数，<code>this</code>的值就会指向调用者bar；<br>3 、将obj.foo赋给一个新对象baz，通过baz()调用foo函数，此时的this指向window；</p>\n<p>由此我们可以得出结论：</p>\n<p>1、普通函数的this总是指向它的直接调用者。<br>2、在严格模式下，没找到直接调用者，则函数中的<code>this</code>是<code>undefined</code>。<br>3、在默认模式下（非严格模式），没找到直接调用者，则函数中的<code>this</code>指向<code>window</code>。</p>\n<p>再考虑一下下面的情况：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span> : <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">foo</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.a),<span class=\"number\">3000</span>&#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.foo(); <span class=\"comment\">//undefined</span></span><br></pre></td></tr></table></figure>\n<p>你可能会认为此时的输出应该为1，但是结果却是<code>undefined</code>。因为此时this的指向是全局的<code>window</code>对象。<br>通过以上例子，可以得出以下总结：</p>\n<p>1、对于方法（即通过对象调用了该函数），普通函数中的<code>this</code>总是指向它的调用者。<br>2、对于一般函数，this指向全局变量（非严格模式下）或者<code>undefined</code>（严格模式下）。在上例中setTimeout中的function未被任何对象调用，因此它的<code>this</code>指向还是<code>window</code>对象。因此，这也可以总结成：javascript 的<code>this</code>可以简单的认为是后期绑定，没有地方绑定的时候，默认绑定<code>window</code>或<code>undefined</code>。</p>\n<p>如果我们希望可以在上例的setTimeout函数中使用<code>this</code>要怎么做呢？在箭头函数出现之前，我们往往会使用以下两种方法：</p>\n<p>1、在setTimeout函数的外部，也就是上层函数<code>foo</code>内部通过将<code>this</code>值赋给一个临时变量来实现。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span> : <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">foo</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> that  = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"built_in\">console</span>.log(that.a),<span class=\"number\">3000</span>&#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.foo(); <span class=\"comment\">//1</span></span><br></pre></td></tr></table></figure>\n<p>2、通过<code>bind()</code>来绑定<code>this</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span> : <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">foo</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.a),<span class=\"number\">3000</span>&#125;.bind(<span class=\"built_in\">this</span>))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.foo(); <span class=\"comment\">//1</span></span><br></pre></td></tr></table></figure>\n<p>这种现象在ES6引入箭头函数后得到了改善。</p>\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><p>箭头函数是ES6中引入的新特性，使用方法为：</p>\n<p>其中()内是要带入的参数，{}内是要执行的语句。箭头函数是函数式编程的一种体现，函数式编程将更多的关注点放在输入和输出的关系，省去了过程的一些因素，因此箭头函数中没有自己的<code>this</code>，<code>arguments</code>，<code>new target（ES6）</code>和 <code>super(ES6)</code>。箭头函数相当于匿名函数，因此不能使用<code>new</code>来作为构造函数使用。</p>\n<p>箭头函数中的this始终指向其父级作用域中的<code>this</code>。换句话说，箭头函数会捕获其所在的上下文的<code>this</code>值，作为自己的<code>this</code>值。任何方法都改变不了其指向，如<code>call(), bind(), apply()</code>。在箭头函数中调用 <code>this</code>时，仅仅是简单的沿着作用域链向上寻找，找到最近的一个 this 拿来使用，它与调用时的上下文无关。我们用代码来解释一下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">10</span>,</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.a); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>); <span class=\"comment\">// Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …&#125;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">c</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.a); <span class=\"comment\">// 10</span></span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>); <span class=\"comment\">// &#123;a: 10, b: ƒ, c: ƒ&#125;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">d</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.a); <span class=\"comment\">// 10</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">e</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      setTime</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  obj.b(); </span><br><span class=\"line\">  obj.c();</span><br><span class=\"line\">  obj.d()();</span><br></pre></td></tr></table></figure>\n<p>简单分析一下代码，obj.b（）中的<code>this</code>会继承父级上下文中的<code>this</code>值，也就是与obj有相同的<code>this</code>指向，为全局变量<code>window</code>。obj.c()的<code>this</code>指向即为调用者obj，obj.d().()中的<code>this</code>也继承自父级上下文中的<code>this</code>，即d的<code>this</code>指向，也就是obj。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><strong>箭头函数没有自己的<code>this</code>，箭头函数的<code>this </code>不是调用的时候决定的，而是在定义的时候处在的对象就是它的<code>this</code>。<br>箭头函数的<code>this</code>看外层是否有函数，如果有，外层函数的<code>this</code>就是内部箭头函数的<code>this</code>，如果没有，则<code>this</code>，是<code>window</code>。</strong></p>","categories":[{"name":"JavaScript","path":"api/categories/JavaScript.json"}],"tags":[{"name":"ES6","path":"api/tags/ES6.json"}]}