{"title":"JavaScript --- DOM  document 扩展","slug":"24","date":"2020-05-24T13:48:01.000Z","updated":"2022-07-29T04:22:04.783Z","comments":true,"path":"api/articles/24.json","excerpt":" [Figure] ","covers":["https://qny.aqingya.cn/img/fd7621d555e24b87acff439298964d1b.jpg"],"content":"<p><img src=\"https://qny.aqingya.cn/img/fd7621d555e24b87acff439298964d1b.jpg\"></p>\n<span id=\"more\"></span>\n\n<h2 id=\"选择符API\"><a href=\"#选择符API\" class=\"headerlink\" title=\"选择符API\"></a>选择符API</h2><p>1、querySlector()方法</p>\n<p>querySlector()方法接受一个CSS选择器，<span style=\"color:red;\">返回与该模式匹配的第一个元素</span>。通过Document类型调用querySlector()方法时，会在文档元素的范围内查找匹配的元素。而通过Element类型调用querySlector()方法时，只会在该元素的范围内查找匹配的元素。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//取得body元素</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> body = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">&quot;body&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//取得ID为“mydiv”的元素</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myDiv = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">&quot;#mydiv&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//取得类为 &quot;selected&quot;的第一个元素</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> selected = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">&quot;.selected&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//取得button元素的第一个图像</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> img = <span class=\"built_in\">document</span>.body.querySelector(<span class=\"string\">&quot;img.button&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>2、querySelectorAll()方法</p>\n<p>querySelectAll()方法接受的参数与querySelect()方法一样都是一个CSS选择符，但querySelectAll()方法返回的是一个NodeList的实例，不仅仅是一个元素，而是所有匹配到的都会在NodeList中。只要querySelectAll()方法的CSS选择符有效，该方法都会返回一个NodeList对象，不管匹配到多少元素，就算是空的，也会返回一个Nodelist。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//取得所有类为 &quot;selected&quot;的元素</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> selected = <span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">&quot;.selected&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>3、matchesSelector()方法</p>\n<p>Element类型新增的一个方法matchesSelector()，接受一个CSS选择符为参数，如果调用元素与该选择符匹配，返回true；否则返回false。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"built_in\">document</span>.body.matchesSelctor(<span class=\"string\">&quot;body.page1&quot;</span>))&#123;</span><br><span class=\"line\">     <span class=\"comment\">//true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"与类相关的扩充\"><a href=\"#与类相关的扩充\" class=\"headerlink\" title=\"与类相关的扩充\"></a>与类相关的扩充</h2><p><strong>classList属性</strong><br>为所有元素添加classList属性。它自己有一个表示自己包含多少元素的属性，取得每个元素可以使用item()方法，也可以使用方括号语法。此外还有如下方法：</p>\n<p><strong>add(value)：将给定的字符串值添加到列表中，如果值已经存在，就不添加了。<br>contains(value)：表示列表中是否存在给定的值，如果存在就返回true，否则返回flase。<br>remove(value)：从列表中删除给定的字符串。<br>toggle(value)：如果列表中已经存在给定的值，则删除它；如果列表中没有给定的值，则添加它。</strong></p>\n<p><strong>支持chrome和Firfox 3.6和IE10以上。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//向div元素中添加div类</span></span><br><span class=\"line\">div.classList.add(<span class=\"string\">&quot;div&quot;</span>)</span><br><span class=\"line\">    <span class=\"comment\">//检查div类</span></span><br><span class=\"line\">div.classList.contains(<span class=\"string\">&quot;div&quot;</span>)</span><br><span class=\"line\">    <span class=\"comment\">//删除div类</span></span><br><span class=\"line\">div.classList.remove(<span class=\"string\">&quot;div&quot;</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 切换div类</span></span><br><span class=\"line\">div.classList.toggle(<span class=\"string\">&quot;div&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 迭代类名</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; div.classList.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(div.classList[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"焦点管理\"><a href=\"#焦点管理\" class=\"headerlink\" title=\"焦点管理\"></a>焦点管理</h2><p>document.activeElement属性，这个属性始终会引用DOM中当前获得焦点的元素。元素获取焦点的方式有页面加载，用户输入（通常是按Tab键）,和代码汇总调用focus()方法。</p>\n<p>默认情况下，文档刚刚加载完成时，document.activeElement中保存的是document.body元素的引用。文档加载期间，document.activeElement的值为null。</p>\n<p>另外就是新增了document.hasFocus()方法，这个方法用于确定文档是否获得了焦点。</p>\n<hr>\n<h2 id=\"HTMLDocument的变化\"><a href=\"#HTMLDocument的变化\" class=\"headerlink\" title=\"HTMLDocument的变化\"></a>HTMLDocument的变化</h2><p><strong>1、readyState属性</strong></p>\n<p>它有两个可能的值</p>\n<ul>\n<li>loading，正在加载文档</li>\n<li>complete，已经加载完文档</li>\n</ul>\n<p> 使用document.readyState的最恰当方式，就是通过它来实现一个指示文档已经加载完成的指示器。用法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"built_in\">document</span>.readyState ==<span class=\"string\">&quot;complete&quot;</span>)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 执行操作</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p><strong>2、兼容模式</strong></p>\n<p>这个属性是为了告诉开发人员浏览器采用的哪种渲染模式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">document</span>.compatMode == <span class=\"string\">&quot;CSS1Compat&quot;</span>) &#123;</span><br><span class=\"line\">    alert(<span class=\"string\">&quot;Standards mode&quot;</span>); <span class=\"comment\">//标准模式</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    alert(<span class=\"string\">&quot;Quirks mode&quot;</span>) <span class=\"comment\">//混杂模式</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><strong>3、head属性</strong><br>引用文档的&lt;head&gt;元素，可以结合使用这个属性和另一种后备方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> head = <span class=\"built_in\">document</span>.head || <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">&quot;head&quot;</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"comment\">//如果有head属性就使用，否则仍然使用document.getElementsByTatName(&quot;head&quot;)[0];</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"字符集属性\"><a href=\"#字符集属性\" class=\"headerlink\" title=\"字符集属性\"></a>字符集属性</h2><p>charset属性表示文档中实际使用的字符集，也可以直接设置。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.charset</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"插入标记\"><a href=\"#插入标记\" class=\"headerlink\" title=\"插入标记\"></a>插入标记</h2><p><strong>1、innerHTML属性</strong></p>\n<p>在读模式下，innerHTML属性返回与调用元素的所有子节点（包括元素，注释和文本节点）和对应的HTML标记。在写模式下，innerHTML会根据指定的值创建新的DOM树，然后用这个DOM树完全替换调用元素原先的所有子节点。</p>\n<p>不是所有的元素都支持innerHTML属性。不支持innerHTML的元素有：&lt;col&gt;、&lt;colgroup&gt;、&lt;frameset&gt;、&lt;head&gt;、&lt;html&gt;、&lt;style&gt;、&lt;tbody&gt;、&lt;thead&gt;、&lt;tfoot&gt;、&lt;tr&gt;，在IE8及更早的版本中，&lt;title&gt;元素也没有innerHTML属性。</p>\n<p><strong>2、outerHTML属性</strong></p>\n<p>在读模式下，outerHTML属性返回调用它的元素所有子节点的HTML标签，在写模式下，outerHTML根据指定的值创建新的DOM树，然后用这个DOM树完全替换调用元素。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div.outerHTML = <span class=\"string\">&quot;&lt;p&gt;aqing&lt;/p&gt;&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">//上面的效果和下面的一样</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">&quot;p&quot;</span>);</span><br><span class=\"line\">p.appendChild(<span class=\"built_in\">document</span>.createTextNode(<span class=\"string\">&quot;&lt;p&gt;aqing&lt;/p&gt;&quot;</span>));</span><br><span class=\"line\">div.parentNode.replaceChild(p, div);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><strong>3、insertAdjacentHTMl()方法</strong></p>\n<p>它接收两个参数：<strong>插入的位置</strong>和<strong>要插入的HTML文本</strong>。第一个参数必须是下列值之一：</p>\n<p>“beforebegin”，在当前元素之下插入一个紧邻的同辈元素；<br>“afterbegin”，在当前元素之下插入一个新的子元素或在第一个子元素之前在插入新的子元素；<br>“beforeend”，在当前元素之下插入一个新的子元素或在最后一个子元素之后在插入新的子元素；<br>“afterend”，在当前元素之后插入一个紧邻的同辈元素；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div.insertAdjacentHTML(<span class=\"string\">&quot;beforeBegin&quot;</span>, <span class=\"string\">&quot;&lt;p&gt;aqing&lt;/p&gt;&quot;</span>)</span><br><span class=\"line\">div.insertAdjacentHTML(<span class=\"string\">&quot;afterEnd&quot;</span>, <span class=\"string\">&quot;&lt;p&gt;aqing&lt;/p&gt;&quot;</span>)</span><br><span class=\"line\">div.insertAdjacentHTML(<span class=\"string\">&quot;afterBegin&quot;</span>, <span class=\"string\">&quot;&lt;p&gt;aqing&lt;/p&gt;&quot;</span>)</span><br><span class=\"line\">div.insertAdjacentHTML(<span class=\"string\">&quot;beforeEnd&quot;</span>, <span class=\"string\">&quot;&lt;p&gt;aqing&lt;/p&gt;&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n\n<p><strong>4、innerText属性</strong></p>\n<p>通过innerText 属性可以操作元素中包含所有文本内容，包括子文档树中的文本。通过innerText 读取值时，他会按照由浅入深的顺序，将子文档树中的所有文本拼接起来。再通过innerText 写入值时，结果会删除所有子节点，插入包含响应文本值的文本节点。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div.innerText = div.innerText;</span><br></pre></td></tr></table></figure>\n<p>执行这行代码后，就用原来的文本内容替换了容器中的所有内容（包含子节点，因而也就去掉了HTML标签）。</p>\n<p><strong>5、outerText 属性</strong></p>\n<p>除了作用范围变大到了包含调用它的节点之外，outerText与innerHTML 基本只上没有多大的区别。<br>在读取文本值时，结果完全一样。但在写模式下，outerText 就完全不同了：outerText 不只是替换调用它的元素子节点，而是会替换整个元素（包括子节点）。<br><strong>由于这个属性会导致调用它的元素不存在，因此并不常用。</strong></p>\n<hr>\n<h2 id=\"scrollIntoView-方法\"><a href=\"#scrollIntoView-方法\" class=\"headerlink\" title=\"scrollIntoView()方法\"></a>scrollIntoView()方法</h2><p>滚动页面，可以在所有HTML元素上调用，通过滚动浏览器窗口或某个容器元素，调用元素就可以出现在视口中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div.scrollIntoView();</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"contains-方法\"><a href=\"#contains-方法\" class=\"headerlink\" title=\"contains()方法\"></a>contains()方法</h2><p>调用contains()方法的应该是祖先节点，也就是搜索开始的节点，这个方法接收一个参数，即要检测的后代节点。如果被检测到的节点是后代节点，该方法返回true，否则返回false</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">document</span>.documentElement.contains(<span class=\"built_in\">document</span>.body));</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>测试&lt;body&gt;元素是不是&lt;html&gt;元素的后代。</p>\n<hr>\n<br>\n<br>\n愿你的坚持终有收获。\n<br>\n<br>\n","more":"<h2 id=\"选择符API\"><a href=\"#选择符API\" class=\"headerlink\" title=\"选择符API\"></a>选择符API</h2><p>1、querySlector()方法</p>\n<p>querySlector()方法接受一个CSS选择器，<span style=\"color:red;\">返回与该模式匹配的第一个元素</span>。通过Document类型调用querySlector()方法时，会在文档元素的范围内查找匹配的元素。而通过Element类型调用querySlector()方法时，只会在该元素的范围内查找匹配的元素。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//取得body元素</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> body = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">&quot;body&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//取得ID为“mydiv”的元素</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myDiv = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">&quot;#mydiv&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//取得类为 &quot;selected&quot;的第一个元素</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> selected = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">&quot;.selected&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//取得button元素的第一个图像</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> img = <span class=\"built_in\">document</span>.body.querySelector(<span class=\"string\">&quot;img.button&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>2、querySelectorAll()方法</p>\n<p>querySelectAll()方法接受的参数与querySelect()方法一样都是一个CSS选择符，但querySelectAll()方法返回的是一个NodeList的实例，不仅仅是一个元素，而是所有匹配到的都会在NodeList中。只要querySelectAll()方法的CSS选择符有效，该方法都会返回一个NodeList对象，不管匹配到多少元素，就算是空的，也会返回一个Nodelist。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//取得所有类为 &quot;selected&quot;的元素</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> selected = <span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">&quot;.selected&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>3、matchesSelector()方法</p>\n<p>Element类型新增的一个方法matchesSelector()，接受一个CSS选择符为参数，如果调用元素与该选择符匹配，返回true；否则返回false。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"built_in\">document</span>.body.matchesSelctor(<span class=\"string\">&quot;body.page1&quot;</span>))&#123;</span><br><span class=\"line\">     <span class=\"comment\">//true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"与类相关的扩充\"><a href=\"#与类相关的扩充\" class=\"headerlink\" title=\"与类相关的扩充\"></a>与类相关的扩充</h2><p><strong>classList属性</strong><br>为所有元素添加classList属性。它自己有一个表示自己包含多少元素的属性，取得每个元素可以使用item()方法，也可以使用方括号语法。此外还有如下方法：</p>\n<p><strong>add(value)：将给定的字符串值添加到列表中，如果值已经存在，就不添加了。<br>contains(value)：表示列表中是否存在给定的值，如果存在就返回true，否则返回flase。<br>remove(value)：从列表中删除给定的字符串。<br>toggle(value)：如果列表中已经存在给定的值，则删除它；如果列表中没有给定的值，则添加它。</strong></p>\n<p><strong>支持chrome和Firfox 3.6和IE10以上。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//向div元素中添加div类</span></span><br><span class=\"line\">div.classList.add(<span class=\"string\">&quot;div&quot;</span>)</span><br><span class=\"line\">    <span class=\"comment\">//检查div类</span></span><br><span class=\"line\">div.classList.contains(<span class=\"string\">&quot;div&quot;</span>)</span><br><span class=\"line\">    <span class=\"comment\">//删除div类</span></span><br><span class=\"line\">div.classList.remove(<span class=\"string\">&quot;div&quot;</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 切换div类</span></span><br><span class=\"line\">div.classList.toggle(<span class=\"string\">&quot;div&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 迭代类名</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; div.classList.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(div.classList[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"焦点管理\"><a href=\"#焦点管理\" class=\"headerlink\" title=\"焦点管理\"></a>焦点管理</h2><p>document.activeElement属性，这个属性始终会引用DOM中当前获得焦点的元素。元素获取焦点的方式有页面加载，用户输入（通常是按Tab键）,和代码汇总调用focus()方法。</p>\n<p>默认情况下，文档刚刚加载完成时，document.activeElement中保存的是document.body元素的引用。文档加载期间，document.activeElement的值为null。</p>\n<p>另外就是新增了document.hasFocus()方法，这个方法用于确定文档是否获得了焦点。</p>\n<hr>\n<h2 id=\"HTMLDocument的变化\"><a href=\"#HTMLDocument的变化\" class=\"headerlink\" title=\"HTMLDocument的变化\"></a>HTMLDocument的变化</h2><p><strong>1、readyState属性</strong></p>\n<p>它有两个可能的值</p>\n<ul>\n<li>loading，正在加载文档</li>\n<li>complete，已经加载完文档</li>\n</ul>\n<p> 使用document.readyState的最恰当方式，就是通过它来实现一个指示文档已经加载完成的指示器。用法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"built_in\">document</span>.readyState ==<span class=\"string\">&quot;complete&quot;</span>)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 执行操作</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p><strong>2、兼容模式</strong></p>\n<p>这个属性是为了告诉开发人员浏览器采用的哪种渲染模式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">document</span>.compatMode == <span class=\"string\">&quot;CSS1Compat&quot;</span>) &#123;</span><br><span class=\"line\">    alert(<span class=\"string\">&quot;Standards mode&quot;</span>); <span class=\"comment\">//标准模式</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    alert(<span class=\"string\">&quot;Quirks mode&quot;</span>) <span class=\"comment\">//混杂模式</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><strong>3、head属性</strong><br>引用文档的&lt;head&gt;元素，可以结合使用这个属性和另一种后备方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> head = <span class=\"built_in\">document</span>.head || <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">&quot;head&quot;</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"comment\">//如果有head属性就使用，否则仍然使用document.getElementsByTatName(&quot;head&quot;)[0];</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"字符集属性\"><a href=\"#字符集属性\" class=\"headerlink\" title=\"字符集属性\"></a>字符集属性</h2><p>charset属性表示文档中实际使用的字符集，也可以直接设置。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.charset</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"插入标记\"><a href=\"#插入标记\" class=\"headerlink\" title=\"插入标记\"></a>插入标记</h2><p><strong>1、innerHTML属性</strong></p>\n<p>在读模式下，innerHTML属性返回与调用元素的所有子节点（包括元素，注释和文本节点）和对应的HTML标记。在写模式下，innerHTML会根据指定的值创建新的DOM树，然后用这个DOM树完全替换调用元素原先的所有子节点。</p>\n<p>不是所有的元素都支持innerHTML属性。不支持innerHTML的元素有：&lt;col&gt;、&lt;colgroup&gt;、&lt;frameset&gt;、&lt;head&gt;、&lt;html&gt;、&lt;style&gt;、&lt;tbody&gt;、&lt;thead&gt;、&lt;tfoot&gt;、&lt;tr&gt;，在IE8及更早的版本中，&lt;title&gt;元素也没有innerHTML属性。</p>\n<p><strong>2、outerHTML属性</strong></p>\n<p>在读模式下，outerHTML属性返回调用它的元素所有子节点的HTML标签，在写模式下，outerHTML根据指定的值创建新的DOM树，然后用这个DOM树完全替换调用元素。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div.outerHTML = <span class=\"string\">&quot;&lt;p&gt;aqing&lt;/p&gt;&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">//上面的效果和下面的一样</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">&quot;p&quot;</span>);</span><br><span class=\"line\">p.appendChild(<span class=\"built_in\">document</span>.createTextNode(<span class=\"string\">&quot;&lt;p&gt;aqing&lt;/p&gt;&quot;</span>));</span><br><span class=\"line\">div.parentNode.replaceChild(p, div);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><strong>3、insertAdjacentHTMl()方法</strong></p>\n<p>它接收两个参数：<strong>插入的位置</strong>和<strong>要插入的HTML文本</strong>。第一个参数必须是下列值之一：</p>\n<p>“beforebegin”，在当前元素之下插入一个紧邻的同辈元素；<br>“afterbegin”，在当前元素之下插入一个新的子元素或在第一个子元素之前在插入新的子元素；<br>“beforeend”，在当前元素之下插入一个新的子元素或在最后一个子元素之后在插入新的子元素；<br>“afterend”，在当前元素之后插入一个紧邻的同辈元素；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div.insertAdjacentHTML(<span class=\"string\">&quot;beforeBegin&quot;</span>, <span class=\"string\">&quot;&lt;p&gt;aqing&lt;/p&gt;&quot;</span>)</span><br><span class=\"line\">div.insertAdjacentHTML(<span class=\"string\">&quot;afterEnd&quot;</span>, <span class=\"string\">&quot;&lt;p&gt;aqing&lt;/p&gt;&quot;</span>)</span><br><span class=\"line\">div.insertAdjacentHTML(<span class=\"string\">&quot;afterBegin&quot;</span>, <span class=\"string\">&quot;&lt;p&gt;aqing&lt;/p&gt;&quot;</span>)</span><br><span class=\"line\">div.insertAdjacentHTML(<span class=\"string\">&quot;beforeEnd&quot;</span>, <span class=\"string\">&quot;&lt;p&gt;aqing&lt;/p&gt;&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n\n<p><strong>4、innerText属性</strong></p>\n<p>通过innerText 属性可以操作元素中包含所有文本内容，包括子文档树中的文本。通过innerText 读取值时，他会按照由浅入深的顺序，将子文档树中的所有文本拼接起来。再通过innerText 写入值时，结果会删除所有子节点，插入包含响应文本值的文本节点。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div.innerText = div.innerText;</span><br></pre></td></tr></table></figure>\n<p>执行这行代码后，就用原来的文本内容替换了容器中的所有内容（包含子节点，因而也就去掉了HTML标签）。</p>\n<p><strong>5、outerText 属性</strong></p>\n<p>除了作用范围变大到了包含调用它的节点之外，outerText与innerHTML 基本只上没有多大的区别。<br>在读取文本值时，结果完全一样。但在写模式下，outerText 就完全不同了：outerText 不只是替换调用它的元素子节点，而是会替换整个元素（包括子节点）。<br><strong>由于这个属性会导致调用它的元素不存在，因此并不常用。</strong></p>\n<hr>\n<h2 id=\"scrollIntoView-方法\"><a href=\"#scrollIntoView-方法\" class=\"headerlink\" title=\"scrollIntoView()方法\"></a>scrollIntoView()方法</h2><p>滚动页面，可以在所有HTML元素上调用，通过滚动浏览器窗口或某个容器元素，调用元素就可以出现在视口中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div.scrollIntoView();</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"contains-方法\"><a href=\"#contains-方法\" class=\"headerlink\" title=\"contains()方法\"></a>contains()方法</h2><p>调用contains()方法的应该是祖先节点，也就是搜索开始的节点，这个方法接收一个参数，即要检测的后代节点。如果被检测到的节点是后代节点，该方法返回true，否则返回false</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">document</span>.documentElement.contains(<span class=\"built_in\">document</span>.body));</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>测试&lt;body&gt;元素是不是&lt;html&gt;元素的后代。</p>\n<hr>\n<br>\n<br>\n愿你的坚持终有收获。\n<br>\n<br>","categories":[{"name":"DOM","path":"api/categories/DOM.json"}],"tags":[{"name":"JavaScript","path":"api/tags/JavaScript.json"},{"name":"DOM","path":"api/tags/DOM.json"}]}