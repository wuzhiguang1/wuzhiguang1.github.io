{"title":"JavaScript  ---  继承总结","slug":"twenty-seven","date":"2020-05-18T07:05:59.000Z","updated":"2022-07-29T04:22:04.750Z","comments":true,"path":"api/articles/twenty-seven.json","excerpt":" [Figure] ","covers":["https://qny.aqingya.cn/img/2fb0db544bd443fc92a359d3a9941076.jpg"],"content":"<p><img src=\"https://qny.aqingya.cn/img/2fb0db544bd443fc92a359d3a9941076.jpg\"></p>\n<span id=\"more\"></span>\n\n<h2 id=\"ES5中的继承\"><a href=\"#ES5中的继承\" class=\"headerlink\" title=\"ES5中的继承\"></a>ES5中的继承</h2><p><strong>一、 原型链继承</strong></p>\n<p>原型链继承的原理：直接让子类的原型对象指向父类实例，当子类实例找不到对应的属性和方法时，就会往它的原型对象，也就是父类实例上找，从而实现对父类的属性和方法的继承。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 父类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fat</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">this</span>.name = <span class=\"string\">&#x27;aqing&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 父类上的原型方法</span></span><br><span class=\"line\">fat.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 子类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">child</span> (<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">// 子类的原型对象方法指向父类 子类中找不到的属性方法就会向父类找</span></span><br><span class=\"line\">child.prototype = <span class=\"keyword\">new</span> fat()</span><br><span class=\"line\"><span class=\"comment\">// 不影响继承 顺便绑一下constructor</span></span><br><span class=\"line\">child.prototype.constructor = child</span><br><span class=\"line\"><span class=\"comment\">// child实例就可以访问父类及其原型上的属性和方法了</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Child = <span class=\"keyword\">new</span> child()</span><br><span class=\"line\">Child.name <span class=\"comment\">// &#x27;aqing&#x27;</span></span><br><span class=\"line\">Child.getName() <span class=\"comment\">// &#x27;aqing&#x27;</span></span><br></pre></td></tr></table></figure>\n<p><strong>原型链继承的缺点</strong></p>\n<ol>\n<li><p>所有的child实例原型都指向同一个fat实例，因此对child实例修改某个父类引用类型会影响所有的child实例；</p>\n</li>\n<li><p>创建子类时无法向父类传参，没有实现super()的功能.</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fat</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">this</span>.name = <span class=\"string\">&#x27;aqing&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fat.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">child</span> (<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">child.prototype = <span class=\"keyword\">new</span> fat()</span><br><span class=\"line\">child.prototype.constructor = child</span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Child1 = <span class=\"keyword\">new</span> child();</span><br><span class=\"line\"><span class=\"keyword\">const</span> Child2 = <span class=\"keyword\">new</span> child();</span><br><span class=\"line\">Child1.name = <span class=\"string\">&#x27;wzg&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Child1.name) <span class=\"comment\">// wzg</span></span><br><span class=\"line\"><span class=\"comment\">// 本来父类name属性是zaq 然后现在==</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Child2.name) <span class=\"comment\">// wzg</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>二、 构造函数继承</strong></p>\n<p>构造函数继承：在子类的构造函数中执行父类的构造函数，并为其绑定子类的this。让父类的构造函数把成员的属性和方法都挂在子类的this上，这样既避免了共用一个原型实例，又能像父类构造函数传参。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fat</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fat.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    fat.call(<span class=\"built_in\">this</span>, name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> child1 = <span class=\"keyword\">new</span> Child(<span class=\"string\">&quot;aqing&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> child2 = <span class=\"keyword\">new</span> Child(<span class=\"string\">&quot;aqing&quot;</span>)</span><br><span class=\"line\">child1.name = <span class=\"string\">&#x27;wzg&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child1.name) <span class=\"comment\">// wzg</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child2.name) <span class=\"comment\">// aqing</span></span><br></pre></td></tr></table></figure>\n<p><strong>构造函数继承的缺点</strong><br>继承不到父类上的属性和方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">child1.getName() <span class=\"comment\">// Uncaught TypeError: child1.getName is not a function</span></span><br></pre></td></tr></table></figure>\n\n\n<p><strong>三 、组合式继承</strong><br>既然原型链继承和构造函数继承都有各自的缺点但是又能互补，那何不将两者结合起来使用；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fat</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fat.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 构造函数继承</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    fat.call(<span class=\"built_in\">this</span>, name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 原型链继承</span></span><br><span class=\"line\">Child.prototype = <span class=\"keyword\">new</span> fat();</span><br><span class=\"line\">Child.prototype.constructor = Child;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> child1 = <span class=\"keyword\">new</span> Child(<span class=\"string\">&quot;aqing&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> child2 = <span class=\"keyword\">new</span> Child(<span class=\"string\">&quot;aq&quot;</span>);</span><br><span class=\"line\">child1.name = <span class=\"string\">&#x27;wzg&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child1.name); <span class=\"comment\">//  wzg</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child2.name); <span class=\"comment\">// aq</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child1.getName()); <span class=\"comment\">//wzg</span></span><br></pre></td></tr></table></figure>\n<p><strong>组合式继承的缺点</strong><br>每次创建子类实例都执行了两次构造函数（fat.call()和new fat()），虽然不影响继承，但是在子类创建时 原型中会存在两份相同的属性和方法。</p>\n<p><strong>四 、寄生式组合继承</strong></p>\n<p>为了解决构造函数被执行两次的问题，我们将指向父类实例 变成转向父类原型，减少一次构造函数的执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fat</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fat.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 构造函数继承</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    fat.call(<span class=\"built_in\">this</span>, name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 原型链继承</span></span><br><span class=\"line\">Child.prototype = fat.prototype <span class=\"comment\">// 将指向父类实例转成转向父类原型</span></span><br><span class=\"line\">Child.prototype.constructor = Child;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> child1 = <span class=\"keyword\">new</span> Child(<span class=\"string\">&quot;aqing&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> child2 = <span class=\"keyword\">new</span> Child(<span class=\"string\">&quot;aqing&quot;</span>);</span><br><span class=\"line\">child1.name = <span class=\"string\">&#x27;wzg&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child1.name); <span class=\"comment\">// wzg</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child2.name); <span class=\"comment\">// aqing</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child1.getName()); <span class=\"comment\">// wzg</span></span><br></pre></td></tr></table></figure>\n<p>但是这种方法也存在一个问题，就是子类和父类的原型都指向同一个对象，如果我们对子类原型操作就会对父类原型产生影响。比如给子类Child.prototype新增一个getName方法,那么父类fat.prototype也增加或是被覆盖一个getName方法。为了解决这个问题 我们给fat.prototype做一个浅拷贝；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fat</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fat.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 构造函数继承</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    fat.call(<span class=\"built_in\">this</span>, name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 原型链继承</span></span><br><span class=\"line\">Child.prototype = <span class=\"built_in\">Object</span>.create(fat.prototype) <span class=\"comment\">// 将指向父类实例转成转向父类原型</span></span><br><span class=\"line\">Child.prototype.constructor = Child;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> child1 = <span class=\"keyword\">new</span> Child(<span class=\"string\">&quot;aqing&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> child2 = <span class=\"keyword\">new</span> Child(<span class=\"string\">&quot;aqing&quot;</span>);</span><br><span class=\"line\">child1.name = <span class=\"string\">&#x27;wzg&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child1.name); <span class=\"comment\">// wzg</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child2.name); <span class=\"comment\">// aqing</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child1.getName()); <span class=\"comment\">// wzg</span></span><br><span class=\"line\">Child.prototype.sayname = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;sayname&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"keyword\">new</span> fat();</span><br><span class=\"line\">child1.sayname(); <span class=\"comment\">//saynem</span></span><br><span class=\"line\">f.sayname();   <span class=\"comment\">//Uncaught TypeError: f.sayname is not a function</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"ES6中的继承\"><a href=\"#ES6中的继承\" class=\"headerlink\" title=\"ES6中的继承\"></a>ES6中的继承</h2><p>class介绍<a href=\"https://github.com/ruanyf/es6tutorial/blob/57701fcc2e4c972b5fa6be236362f0b57b97bab4/docs/class.md\">来自阮一峰</a><br>es6中的继承：<br>1、class可以理解为functon,由于class本质还是一个function，因此它也有一个prototype属性。当new一个class时，会把class的protortype属性赋值给这个新对象的_proto_属性上；<br>2、constructor是默认添加的方法，在new一个对象的时候，会自动调用该方法, constructor里定义自己的属性；<br>3、继承extends和super， class子类名 extends父类名 实现继承。当然，还得在constructor里写上super (父类的参数)，意思就是在子类中获取父类的this指针，相当于fat.call(this)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 父类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">fat</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">props</span>)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.name = props || <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tgetName () &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.name</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 继承</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title\">fat</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">props, attrs</span>)</span> &#123; <span class=\"comment\">// props继承父类的属性，attrs自己私有的属性</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">super</span>(props); <span class=\"comment\">// 相当于获取父类的this指向</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.rename = props.rename || <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.attrs = attrs</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 子类自己的方法</span></span><br><span class=\"line\">\tgetFatname () &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.name</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tgetAttrs () &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.attrs</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 通过new实例化一个构造函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> child1 = <span class=\"keyword\">new</span> Child(&#123;</span><br><span class=\"line\">\t<span class=\"attr\">name</span>: <span class=\"string\">&#x27;wzg&#x27;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">rename</span>: <span class=\"string\">&#x27;aqing&#x27;</span></span><br><span class=\"line\">&#125;, <span class=\"string\">&#x27;wuzhiguang&#x27;</span>)</span><br><span class=\"line\">child1.getName() <span class=\"comment\">// wzg</span></span><br><span class=\"line\">child1.getRename() <span class=\"comment\">// aqing</span></span><br><span class=\"line\">child1.getAttrs() <span class=\"comment\">// wuzhiguang</span></span><br></pre></td></tr></table></figure>\n\n\n<br>\n<br>\n愿你的坚持终有收获。\n<br>\n<br>\n\n","more":"<h2 id=\"ES5中的继承\"><a href=\"#ES5中的继承\" class=\"headerlink\" title=\"ES5中的继承\"></a>ES5中的继承</h2><p><strong>一、 原型链继承</strong></p>\n<p>原型链继承的原理：直接让子类的原型对象指向父类实例，当子类实例找不到对应的属性和方法时，就会往它的原型对象，也就是父类实例上找，从而实现对父类的属性和方法的继承。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 父类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fat</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">this</span>.name = <span class=\"string\">&#x27;aqing&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 父类上的原型方法</span></span><br><span class=\"line\">fat.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 子类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">child</span> (<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">// 子类的原型对象方法指向父类 子类中找不到的属性方法就会向父类找</span></span><br><span class=\"line\">child.prototype = <span class=\"keyword\">new</span> fat()</span><br><span class=\"line\"><span class=\"comment\">// 不影响继承 顺便绑一下constructor</span></span><br><span class=\"line\">child.prototype.constructor = child</span><br><span class=\"line\"><span class=\"comment\">// child实例就可以访问父类及其原型上的属性和方法了</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Child = <span class=\"keyword\">new</span> child()</span><br><span class=\"line\">Child.name <span class=\"comment\">// &#x27;aqing&#x27;</span></span><br><span class=\"line\">Child.getName() <span class=\"comment\">// &#x27;aqing&#x27;</span></span><br></pre></td></tr></table></figure>\n<p><strong>原型链继承的缺点</strong></p>\n<ol>\n<li><p>所有的child实例原型都指向同一个fat实例，因此对child实例修改某个父类引用类型会影响所有的child实例；</p>\n</li>\n<li><p>创建子类时无法向父类传参，没有实现super()的功能.</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fat</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">this</span>.name = <span class=\"string\">&#x27;aqing&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fat.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">child</span> (<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">child.prototype = <span class=\"keyword\">new</span> fat()</span><br><span class=\"line\">child.prototype.constructor = child</span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Child1 = <span class=\"keyword\">new</span> child();</span><br><span class=\"line\"><span class=\"keyword\">const</span> Child2 = <span class=\"keyword\">new</span> child();</span><br><span class=\"line\">Child1.name = <span class=\"string\">&#x27;wzg&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Child1.name) <span class=\"comment\">// wzg</span></span><br><span class=\"line\"><span class=\"comment\">// 本来父类name属性是zaq 然后现在==</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Child2.name) <span class=\"comment\">// wzg</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>二、 构造函数继承</strong></p>\n<p>构造函数继承：在子类的构造函数中执行父类的构造函数，并为其绑定子类的this。让父类的构造函数把成员的属性和方法都挂在子类的this上，这样既避免了共用一个原型实例，又能像父类构造函数传参。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fat</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fat.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    fat.call(<span class=\"built_in\">this</span>, name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> child1 = <span class=\"keyword\">new</span> Child(<span class=\"string\">&quot;aqing&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> child2 = <span class=\"keyword\">new</span> Child(<span class=\"string\">&quot;aqing&quot;</span>)</span><br><span class=\"line\">child1.name = <span class=\"string\">&#x27;wzg&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child1.name) <span class=\"comment\">// wzg</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child2.name) <span class=\"comment\">// aqing</span></span><br></pre></td></tr></table></figure>\n<p><strong>构造函数继承的缺点</strong><br>继承不到父类上的属性和方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">child1.getName() <span class=\"comment\">// Uncaught TypeError: child1.getName is not a function</span></span><br></pre></td></tr></table></figure>\n\n\n<p><strong>三 、组合式继承</strong><br>既然原型链继承和构造函数继承都有各自的缺点但是又能互补，那何不将两者结合起来使用；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fat</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fat.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 构造函数继承</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    fat.call(<span class=\"built_in\">this</span>, name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 原型链继承</span></span><br><span class=\"line\">Child.prototype = <span class=\"keyword\">new</span> fat();</span><br><span class=\"line\">Child.prototype.constructor = Child;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> child1 = <span class=\"keyword\">new</span> Child(<span class=\"string\">&quot;aqing&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> child2 = <span class=\"keyword\">new</span> Child(<span class=\"string\">&quot;aq&quot;</span>);</span><br><span class=\"line\">child1.name = <span class=\"string\">&#x27;wzg&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child1.name); <span class=\"comment\">//  wzg</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child2.name); <span class=\"comment\">// aq</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child1.getName()); <span class=\"comment\">//wzg</span></span><br></pre></td></tr></table></figure>\n<p><strong>组合式继承的缺点</strong><br>每次创建子类实例都执行了两次构造函数（fat.call()和new fat()），虽然不影响继承，但是在子类创建时 原型中会存在两份相同的属性和方法。</p>\n<p><strong>四 、寄生式组合继承</strong></p>\n<p>为了解决构造函数被执行两次的问题，我们将指向父类实例 变成转向父类原型，减少一次构造函数的执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fat</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fat.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 构造函数继承</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    fat.call(<span class=\"built_in\">this</span>, name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 原型链继承</span></span><br><span class=\"line\">Child.prototype = fat.prototype <span class=\"comment\">// 将指向父类实例转成转向父类原型</span></span><br><span class=\"line\">Child.prototype.constructor = Child;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> child1 = <span class=\"keyword\">new</span> Child(<span class=\"string\">&quot;aqing&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> child2 = <span class=\"keyword\">new</span> Child(<span class=\"string\">&quot;aqing&quot;</span>);</span><br><span class=\"line\">child1.name = <span class=\"string\">&#x27;wzg&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child1.name); <span class=\"comment\">// wzg</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child2.name); <span class=\"comment\">// aqing</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child1.getName()); <span class=\"comment\">// wzg</span></span><br></pre></td></tr></table></figure>\n<p>但是这种方法也存在一个问题，就是子类和父类的原型都指向同一个对象，如果我们对子类原型操作就会对父类原型产生影响。比如给子类Child.prototype新增一个getName方法,那么父类fat.prototype也增加或是被覆盖一个getName方法。为了解决这个问题 我们给fat.prototype做一个浅拷贝；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fat</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fat.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 构造函数继承</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    fat.call(<span class=\"built_in\">this</span>, name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 原型链继承</span></span><br><span class=\"line\">Child.prototype = <span class=\"built_in\">Object</span>.create(fat.prototype) <span class=\"comment\">// 将指向父类实例转成转向父类原型</span></span><br><span class=\"line\">Child.prototype.constructor = Child;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> child1 = <span class=\"keyword\">new</span> Child(<span class=\"string\">&quot;aqing&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> child2 = <span class=\"keyword\">new</span> Child(<span class=\"string\">&quot;aqing&quot;</span>);</span><br><span class=\"line\">child1.name = <span class=\"string\">&#x27;wzg&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child1.name); <span class=\"comment\">// wzg</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child2.name); <span class=\"comment\">// aqing</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child1.getName()); <span class=\"comment\">// wzg</span></span><br><span class=\"line\">Child.prototype.sayname = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;sayname&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"keyword\">new</span> fat();</span><br><span class=\"line\">child1.sayname(); <span class=\"comment\">//saynem</span></span><br><span class=\"line\">f.sayname();   <span class=\"comment\">//Uncaught TypeError: f.sayname is not a function</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"ES6中的继承\"><a href=\"#ES6中的继承\" class=\"headerlink\" title=\"ES6中的继承\"></a>ES6中的继承</h2><p>class介绍<a href=\"https://github.com/ruanyf/es6tutorial/blob/57701fcc2e4c972b5fa6be236362f0b57b97bab4/docs/class.md\">来自阮一峰</a><br>es6中的继承：<br>1、class可以理解为functon,由于class本质还是一个function，因此它也有一个prototype属性。当new一个class时，会把class的protortype属性赋值给这个新对象的_proto_属性上；<br>2、constructor是默认添加的方法，在new一个对象的时候，会自动调用该方法, constructor里定义自己的属性；<br>3、继承extends和super， class子类名 extends父类名 实现继承。当然，还得在constructor里写上super (父类的参数)，意思就是在子类中获取父类的this指针，相当于fat.call(this)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 父类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">fat</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">props</span>)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.name = props || <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tgetName () &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.name</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 继承</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title\">fat</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">props, attrs</span>)</span> &#123; <span class=\"comment\">// props继承父类的属性，attrs自己私有的属性</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">super</span>(props); <span class=\"comment\">// 相当于获取父类的this指向</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.rename = props.rename || <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.attrs = attrs</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 子类自己的方法</span></span><br><span class=\"line\">\tgetFatname () &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.name</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tgetAttrs () &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.attrs</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 通过new实例化一个构造函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> child1 = <span class=\"keyword\">new</span> Child(&#123;</span><br><span class=\"line\">\t<span class=\"attr\">name</span>: <span class=\"string\">&#x27;wzg&#x27;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">rename</span>: <span class=\"string\">&#x27;aqing&#x27;</span></span><br><span class=\"line\">&#125;, <span class=\"string\">&#x27;wuzhiguang&#x27;</span>)</span><br><span class=\"line\">child1.getName() <span class=\"comment\">// wzg</span></span><br><span class=\"line\">child1.getRename() <span class=\"comment\">// aqing</span></span><br><span class=\"line\">child1.getAttrs() <span class=\"comment\">// wuzhiguang</span></span><br></pre></td></tr></table></figure>\n\n\n<br>\n<br>\n愿你的坚持终有收获。\n<br>\n<br>","categories":[{"name":"JavaScript","path":"api/categories/JavaScript.json"}],"tags":[{"name":"JavaScript","path":"api/tags/JavaScript.json"}]}