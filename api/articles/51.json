{"title":"JavaScript基础面试题","slug":"51","date":"2020-07-11T14:16:11.000Z","updated":"2022-07-29T04:22:04.776Z","comments":true,"path":"api/articles/51.json","excerpt":" [Figure] ","covers":["https://qny.aqingya.cn/img/photo-1558338043-7f8d437d3188.png"],"content":"<p><img src=\"https://qny.aqingya.cn/img/photo-1558338043-7f8d437d3188.png\"></p>\n<span id=\"more\"></span>\n\n\n\n<h3 id=\"1、-介绍JavaScript的基本数据类型\"><a href=\"#1、-介绍JavaScript的基本数据类型\" class=\"headerlink\" title=\"1、 介绍JavaScript的基本数据类型\"></a>1、 介绍JavaScript的基本数据类型</h3><p>Number、String 、Boolean 、Null、Undefined<br>Object 是 JavaScript 中所有对象的父对象<br>数据封装类对象：Object、Array、Boolean、Number 和 String<br>其他对象：Function、Arguments、Math、Date、RegExp、Error<br>新类型：Symbol</p>\n<h3 id=\"2、-说说写JavaScript的基本规范？\"><a href=\"#2、-说说写JavaScript的基本规范？\" class=\"headerlink\" title=\"2、 说说写JavaScript的基本规范？\"></a>2、 说说写JavaScript的基本规范？</h3><ol>\n<li>不要在同一行声明多个变量</li>\n<li>使用 ===或!==来比较true/false或者数值</li>\n<li>switch必须带有default分支</li>\n<li>函数应该有返回值</li>\n<li>for if else 必须使用大括号</li>\n<li>语句结束加分号</li>\n<li>命名要有意义，使用驼峰命名法</li>\n</ol>\n<h3 id=\"3、-jQuery使用建议\"><a href=\"#3、-jQuery使用建议\" class=\"headerlink\" title=\"3、 jQuery使用建议\"></a>3、 jQuery使用建议</h3><ol>\n<li>尽量减少对dom元素的访问和操作</li>\n<li>尽量避免给dom元素绑定多个相同类型的事件处理函数，可以将多个相同类型事件<br>处理函数合并到一个处理函数，通过数据状态来处理分支</li>\n<li>尽量避免使用toggle事件</li>\n</ol>\n<h3 id=\"4、-Ajax使用\"><a href=\"#4、-Ajax使用\" class=\"headerlink\" title=\"4、 Ajax使用\"></a>4、 Ajax使用</h3><p>全称 ：Asynchronous Javascript And XML<br>所谓异步，就是向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。<br>创建Ajax的过程：</p>\n<ol>\n<li>创建XMLHttpRequest对象（异步调用对象）</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>创建新的Http请求（方法、URL、是否异步）</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xhr.open(‘get’,’example.php’,<span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>设置响应HTTP请求状态变化的函数。<br>onreadystatechange事件中readyState属性等于4。响应的HTTP状态为200(OK)或者304(Not Modified)。</li>\n<li>发送http请求</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xhr.send(data);</span><br></pre></td></tr></table></figure>\n\n\n<ol start=\"5\">\n<li>获取异步调用返回的数据</li>\n</ol>\n<p>注意：</p>\n<ol>\n<li>页面初次加载时，尽量在web服务器一次性输出所有相关的数据，只在页面加载完成之后，用户进行操作时采用ajax进行交互。</li>\n<li>同步ajax在IE上会产生页面假死的问题。所以建议采用异步ajax。</li>\n<li>尽量减少ajax请求次数</li>\n<li>ajax安全问题，对于敏感数据在服务器端处理，避免在客户端处理过滤。对于关键业务逻辑代码也必须放在服务器端处理。</li>\n</ol>\n<h3 id=\"5、-JavaScript有几种类型的值？你能画一下他们的内存图吗？\"><a href=\"#5、-JavaScript有几种类型的值？你能画一下他们的内存图吗？\" class=\"headerlink\" title=\"5、 JavaScript有几种类型的值？你能画一下他们的内存图吗？\"></a>5、 JavaScript有几种类型的值？你能画一下他们的内存图吗？</h3><p>基本数据类型存储在栈中，引用数据类型（对象）存储在堆中，指针放在栈中。<br>两种类型的区别是：存储位置不同；原始数据类型直接存储在栈中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；引用数据类型存储在堆中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能<br>引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</p>\n<h3 id=\"6、-栈和堆的区别？\"><a href=\"#6、-栈和堆的区别？\" class=\"headerlink\" title=\"6、 栈和堆的区别？\"></a>6、 栈和堆的区别？</h3><p>栈（stack）：由编译器自动分配释放，存放函数的参数值，局部变量等；<br>堆（heap）：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统释放。</p>\n<h3 id=\"7、-Javascript实现继承的几种方式\"><a href=\"#7、-Javascript实现继承的几种方式\" class=\"headerlink\" title=\"7、 Javascript实现继承的几种方式\"></a>7、 Javascript实现继承的几种方式</h3><p>JavaScript实现继承的3种方法<br>1）、借用构造函数法（又叫经典继承）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">window</span>.alert(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    SuperType.call(<span class=\"built_in\">this</span>, name); <span class=\"comment\">//在这里借用了父类的构造函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2）、对象冒充</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">this</span>.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">window</span>.alert(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.supertype = SuperType; <span class=\"comment\">//在这里使用了对象冒充</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.supertype(name);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3）、组合继承（最常用）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">SuperType.prototype = &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"attr\">sayName</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">window</span>.alert(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    SuperType.call(<span class=\"built_in\">this</span>, name); <span class=\"comment\">//在这里继承属性</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">SubType.prototype = <span class=\"keyword\">new</span> SuperType(); <span class=\"comment\">//这里继承方法</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"8-、Javascript创建对象的几种方式？\"><a href=\"#8-、Javascript创建对象的几种方式？\" class=\"headerlink\" title=\"8 、Javascript创建对象的几种方式？\"></a>8 、Javascript创建对象的几种方式？</h3><p>JavaScript定义类的4种方法<br>1）、工厂方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">creatPerson</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    obj.name = name;</span><br><span class=\"line\">    obj.age = age;</span><br><span class=\"line\"></span><br><span class=\"line\">    obj.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">window</span>.alert(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2）、构造函数方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">window</span>.alert(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3）、原型方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">    <span class=\"attr\">constructor</span> : Person,</span><br><span class=\"line\">    <span class=\"attr\">name</span> : <span class=\"string\">&quot;Ning&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">age</span> : <span class=\"string\">&quot;23&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">sayName</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">window</span>.alert(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">大家可以看到这种方法有缺陷，类里属性的值都是在原型里给定的。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4</span>）、组合使用构造函数和原型方法（使用最广）</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">    <span class=\"attr\">constructor</span> : Person,</span><br><span class=\"line\">    <span class=\"attr\">sayName</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">window</span>.alert(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>将构造函数方法和原型方法结合使用是目前最常用的定义类的方法。这种方法的好处是实现了属性定义和方法定义的分离。比如我可以创建两个对象<code>person1</code>和<code>person2</code>，它们分别传入各自的<code>name</code>值和<code>age</code>值，但<code>sayName()</code>方法可以同时使用原型里定义的。</p>\n<h3 id=\"9、Javascript作用链域\"><a href=\"#9、Javascript作用链域\" class=\"headerlink\" title=\"9、Javascript作用链域\"></a>9、Javascript作用链域</h3><p>作用域链的原理和原型链很类似，如果这个变量在自己的作用域中没有，那么它会寻找父级的，直到最顶层。<br>注意：JS没有块级作用域，若要形成块级作用域，可通过（function（）｛｝）（）；立即执行的形式实现。</p>\n<h3 id=\"10、-谈谈this的理解\"><a href=\"#10、-谈谈this的理解\" class=\"headerlink\" title=\"10、 谈谈this的理解\"></a>10、 谈谈this的理解</h3><ol>\n<li>this总是指向函数的直接调用者（而非间接调用者）</li>\n<li>如果有new关键字，this指向new出来的那个对象</li>\n<li>在事件中，this指向目标元素，特殊的是IE的attachEvent中的this总是指向全局对象window。</li>\n</ol>\n<h3 id=\"11、-eval是做什么的？\"><a href=\"#11、-eval是做什么的？\" class=\"headerlink\" title=\"11、 eval是做什么的？\"></a>11、 eval是做什么的？</h3><p>它的功能是把对应的字符串解析成JS代码并运行；应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。</p>\n<h3 id=\"12、-什么是window对象-什么是document对象\"><a href=\"#12、-什么是window对象-什么是document对象\" class=\"headerlink\" title=\"12、 什么是window对象? 什么是document对象?\"></a>12、 什么是window对象? 什么是document对象?</h3><p>window对象代表浏览器中打开的一个窗口。document对象代表整个html文档。实际上，document对象是window对象的一个属性。</p>\n<h3 id=\"13、-null，undefined的区别？\"><a href=\"#13、-null，undefined的区别？\" class=\"headerlink\" title=\"13、 null，undefined的区别？\"></a>13、 null，undefined的区别？</h3><p>null表示一个对象被定义了，但存放了空指针，转换为数值时为0。<br>undefined表示声明的变量未初始化，转换为数值时为NAN。<br>typeof(null) – object;<br>typeof(undefined) – undefined</p>\n<h3 id=\"14、-“1”-“2”-“3”-map-parseInt-答案是多少？\"><a href=\"#14、-“1”-“2”-“3”-map-parseInt-答案是多少？\" class=\"headerlink\" title=\"14、 [“1”, “2”, “3”].map(parseInt) 答案是多少？\"></a>14、 [“1”, “2”, “3”].map(parseInt) 答案是多少？</h3><p>[1,NaN,NaN]</p>\n<p>解析：<br>Array.prototype.map()<br>array.map(callback[, thisArg])<br>callback函数的执行规则<br>参数：自动传入三个参数<br>currentValue（当前被传递的元素）；<br>index（当前被传递的元素的索引）；<br>array（调用map方法的数组）</p>\n<p>parseInt方法接收两个参数<br>第三个参数[“1”, “2”, “3”]将被忽略。parseInt方法将会通过以下方式被调用<br>parseInt(“1”, 0)<br>parseInt(“2”, 1)<br>parseInt(“3”, 2)</p>\n<p>parseInt的第二个参数radix为0时，ECMAScript5将string作为十进制数字的字符串解析；<br>parseInt的第二个参数radix为1时，解析结果为NaN；<br>parseInt的第二个参数radix在2—36之间时，如果string参数的第一个字符（除空白以外），不属于radix指定进制下的字符，解析结果为NaN。<br>parseInt(“3”, 2)执行时，由于”3”不属于二进制字符，解析结果为NaN。</p>\n<h3 id=\"15、关于事件，IE与火狐的事件机制有什么区别？如何阻止冒泡？\"><a href=\"#15、关于事件，IE与火狐的事件机制有什么区别？如何阻止冒泡？\" class=\"headerlink\" title=\"15、关于事件，IE与火狐的事件机制有什么区别？如何阻止冒泡？\"></a>15、关于事件，IE与火狐的事件机制有什么区别？如何阻止冒泡？</h3><p>IE为事件冒泡，Firefox同时支持事件捕获和事件冒泡。但并非所有浏览器都支持事件捕获。jQuery中使用<code>event.stopPropagation()</code>方法可阻止冒泡;（旧IE的方法 <code>ev.cancelBubble = true;</code>）</p>\n<h3 id=\"16、-什么是闭包（closure），为什么要用它？\"><a href=\"#16、-什么是闭包（closure），为什么要用它？\" class=\"headerlink\" title=\"16、 什么是闭包（closure），为什么要用它？\"></a>16、 什么是闭包（closure），为什么要用它？</h3><p>闭包指的是一个函数可以访问另一个函数作用域中变量。常见的构造方法，是在一个函数内部定义另外一个函数。内部函数可以引用外层的变量；外层变量不会被垃圾回收机制回收。<br>注意，闭包的原理是作用域链，所以闭包访问的上级作用域中的变量是个对象，其值为其运算结束后的最后一个值。<br>优点：避免全局变量污染。缺点：容易造成内存泄漏。<br>例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">makeFunc</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">&quot;Mozilla&quot;</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">displayName</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> displayName;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> myFunc = makeFunc();</span><br><span class=\"line\">myFunc();   <span class=\"comment\">//输出Mozilla</span></span><br></pre></td></tr></table></figure>\n<p>myFunc 变成一个 闭包。闭包是一种特殊的对象。它由两部分构成：函数，以及创建该函数的环境。环境由闭包创建时在作用域中的任何局部变量组成。在我们的例子中，myFunc 是一个闭包，由 displayName 函数和闭包创建时存在的 “Mozilla” 字符串形成。</p>\n<h3 id=\"17、javascript-代码中的”use-strict”-是什么意思-使用它区别是什么？\"><a href=\"#17、javascript-代码中的”use-strict”-是什么意思-使用它区别是什么？\" class=\"headerlink\" title=\"17、javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？\"></a>17、javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？</h3><p>除了正常模式运行外，ECMAscript添加了第二种运行模式：“严格模式”。<br>作用：</p>\n<ol>\n<li>消除js不合理，不严谨地方，减少怪异行为</li>\n<li>消除代码运行的不安全之处，</li>\n<li>提高编译器的效率，增加运行速度</li>\n<li>为未来的js新版本做铺垫。</li>\n</ol>\n<h3 id=\"18、-如何判断一个对象是否属于某个类？\"><a href=\"#18、-如何判断一个对象是否属于某个类？\" class=\"headerlink\" title=\"18、 如何判断一个对象是否属于某个类？\"></a>18、 如何判断一个对象是否属于某个类？</h3><p>使用instanceof 即if(a instanceof Person){alert(‘yes’);}</p>\n<h3 id=\"19、-new操作符具体干了什么呢\"><a href=\"#19、-new操作符具体干了什么呢\" class=\"headerlink\" title=\"19、 new操作符具体干了什么呢?\"></a>19、 new操作符具体干了什么呢?</h3><ol>\n<li>创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。</li>\n<li>属性和方法被加入到 this 引用的对象中。</li>\n<li>新创建的对象由 this 所引用，并且最后隐式的返回 this 。</li>\n</ol>\n<h3 id=\"20、-Javascript中，执行时对象查找时，永远不会去查找原型的函数？\"><a href=\"#20、-Javascript中，执行时对象查找时，永远不会去查找原型的函数？\" class=\"headerlink\" title=\"20、 Javascript中，执行时对象查找时，永远不会去查找原型的函数？\"></a>20、 Javascript中，执行时对象查找时，永远不会去查找原型的函数？</h3><p>Object.hasOwnProperty(proName)：是用来判断一个对象是否有你给出名称的属性。不过需要注意的是，此方法无法检查该对象的原型链中是否具有该属性，该属性必须是对象本身的一个成员。</p>\n<h3 id=\"21、-对JSON的了解？\"><a href=\"#21、-对JSON的了解？\" class=\"headerlink\" title=\"21、 对JSON的了解？\"></a>21、 对JSON的了解？</h3><p>全称：JavaScript Object Notation<br>JSON中对象通过“{}”来标识，一个“{}”代表一个对象，如{“AreaId”:”123”}，对象的值是键值对的形式（key：value）。JSON是JS的一个严格的子集，一种轻量级的数据交换格式，类似于xml。数据格式简单，易于读写，占用带宽小。<br>两个函数：<br>JSON.parse(str)<br>解析JSON字符串 把JSON字符串变成JavaScript值或对象<br>JSON.stringify(obj)<br>将一个JavaScript值(对象或者数组)转换为一个 JSON字符串<br>eval(‘(‘＋json＋’)’)<br>用eval方法注意加括号 而且这种方式更容易被攻击</p>\n<h3 id=\"22、-JS延迟加载的方式有哪些？\"><a href=\"#22、-JS延迟加载的方式有哪些？\" class=\"headerlink\" title=\"22、 JS延迟加载的方式有哪些？\"></a>22、 JS延迟加载的方式有哪些？</h3><p>JS的延迟加载有助与提高页面的加载速度。<br>defer和async、动态创建DOM方式（用得最多）、按需异步载入JS<br>defer：延迟脚本。立即下载，但延迟执行（延迟到整个页面都解析完毕后再运行），按照脚本出现的先后顺序执行。<br>async：异步脚本。下载完立即执行，但不保证按照脚本出现的先后顺序执行。</p>\n<h3 id=\"23、-同步和异步的区别\"><a href=\"#23、-同步和异步的区别\" class=\"headerlink\" title=\"23、 同步和异步的区别?\"></a>23、 同步和异步的区别?</h3><p>同步的概念在操作系统中：不同进程协同完成某项工作而先后次序调整（通过阻塞、唤醒等方式），同步强调的是顺序性，谁先谁后。异步不存在顺序性。<br>同步：浏览器访问服务器，用户看到页面刷新，重新发请求，等请求完，页面刷新，新内容出现，用户看到新内容之后进行下一步操作。<br>异步：浏览器访问服务器请求，用户正常操作，浏览器在后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容。</p>\n<h3 id=\"24、-什么是跨域问题-，如何解决跨域问题\"><a href=\"#24、-什么是跨域问题-，如何解决跨域问题\" class=\"headerlink\" title=\"24、 什么是跨域问题 ，如何解决跨域问题?\"></a>24、 什么是跨域问题 ，如何解决跨域问题?</h3><p><strong>什么是跨域？</strong><br>要明白什么是跨域之前，首先要明白什么是<strong>同源策略？</strong></p>\n<p>同源策略就是用来限制从一个源加载的文档或脚本与来自另一个源的资源进行交互。那怎样判断是否是同源呢？</p>\n<p>如果协议，端口（如果指定了）和主机对于两个页面是相同的，则两个页面具有相同的源，也就是同源。也就是说，要同时满足以下3个条件，才能叫同源：</p>\n<p>协议相同</p>\n<p>端口相同</p>\n<p>主机相同</p>\n<p>举个例子就一目了然了：</p>\n<p>我们来看下面的页面是否与 <code>http://store.company.com/dir/index.html</code> 是同源的？</p>\n<p><code>http://store.company.com/dir/index2.html </code>同源</p>\n<p><code>http://store.company.com/dir2/index3.html </code>同源 虽然在不同文件夹下</p>\n<p><code>https://store.company.com/secure.html </code>不同源 不同的协议(https)</p>\n<p><code>http://store.company.com:81/dir/index.html </code>不同源 不同的端口(81)</p>\n<p><code>http://news.company.com/dir/other.html </code>不同源 不同的主机(news)</p>\n<p>跨域的几种解决方案</p>\n<h4 id=\"1）、document-domain方法\"><a href=\"#1）、document-domain方法\" class=\"headerlink\" title=\"1）、document.domain方法\"></a>1）、document.domain方法</h4><p>我们来看一个具体场景：有一个页面 <a href=\"http://www.example.com/a.html\">http://www.example.com/a.html</a> ，它里面有一个iframe，这个iframe的源是 <a href=\"http://example.com/b.html\">http://example.com/b.html</a> ，很显然它们是不同源的，所以我们无法在父页面中操控子页面的内容。</p>\n<p>解决方案如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- b.html --&gt;</span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"><span class=\"built_in\">document</span>.domain = <span class=\"string\">&#x27;example.com&#x27;</span>;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- a.html --&gt;</span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"><span class=\"built_in\">document</span>.domain = <span class=\"string\">&#x27;example.com&#x27;</span>;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"><span class=\"keyword\">var</span> iframe = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;iframe&#x27;</span>).contentWindow.document;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"><span class=\"comment\">//后面就可以操作iframe里的内容了...</span></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>所以我们只要将两个页面的document.domain设置成一致就可以了，要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域。</p>\n<p>但是，这种方法只能解决主域相同的跨域问题。</p>\n<h4 id=\"2）、window-name方法\"><a href=\"#2）、window-name方法\" class=\"headerlink\" title=\"2）、window.name方法\"></a>2）、window.name方法</h4><p>window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。</p>\n<p>我们来看一个具体场景，在一个页面 <code>example.com/a.html </code>中，我们想获取 <code>data.com/data.html </code>中的数据，以下是解决方案：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- data.html --&gt;</span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"><span class=\"built_in\">window</span>.name = <span class=\"string\">&#x27;data&#x27;</span>; <span class=\"comment\">//这是就是我们需要通信的数据</span></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- a.html --&gt;</span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getData</span> (<span class=\"params\"></span>) </span>&#123;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">        <span class=\"keyword\">var</span> iframe = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;iframe&#x27;</span>);</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">        iframe.src = <span class=\"string\">&#x27;example.com/b.html&#x27;</span>; <span class=\"comment\">// 这里让iframe与父页面同源</span></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">        </span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">        iframe.onload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">            <span class=\"keyword\">var</span> data = iframe.contentWindow.name; <span class=\"comment\">//在这里我们得到了跨域页面中传来的数据</span></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">        &#125;;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">    &#125;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3）、JSONP方法\"><a href=\"#3）、JSONP方法\" class=\"headerlink\" title=\"3）、JSONP方法\"></a>3）、JSONP方法</h4><p>JONSP(JSON with Padding)是JSON的一种使用模式。基本原理如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- a.html --&gt;</span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dealData</span> (<span class=\"params\">data</span>) </span>&#123;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">        <span class=\"built_in\">console</span>.log(data);</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">    &#125;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&#x27;http://example.com/data.php?callback=dealData&#x27;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php</span><br><span class=\"line\">    $callback = $_GET[<span class=\"string\">&#x27;callback&#x27;</span>];</span><br><span class=\"line\">    $data = <span class=\"string\">&#x27;data&#x27;</span>;</span><br><span class=\"line\">    echo $callback.<span class=\"string\">&#x27;(&#x27;</span>.json_encode($data).<span class=\"string\">&#x27;)&#x27;</span>;</span><br><span class=\"line\">?&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这时候在<code>a.html</code>中我们得到了一条js的执行语句<code>dealData(&#39;data&#39;)</code>，从而达到了跨域的目的。</p>\n<p>所以JSONP的原理其实就是利用引入<code>script</code>不限制源的特点，把处理函数名作为参数传入，然后返回执行语句，仔细阅读以上代码就可以明白里面的意思了。</p>\n<p>如果在jQuery中用JSONP的话就更加简单了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">$.getJSON(<span class=\"string\">&#x27;&#x27;</span>http:<span class=\"comment\">//example.com/data.php?callback=?&#x27;, function (data) &#123;</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>注意jQuery会自动生成一个全局函数来替换<code>callback=?</code>中的问号，之后获取到数据后又会自动销毁，实际上就是起一个临时代理函数的作用。<code>$.getJSON</code>方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法；跨域的话，则会以异步加载js文件的形式来调用JSONP的回调函数。</p>\n<h3 id=\"25、-页面编码和被请求的资源编码如果不一致如何处理？\"><a href=\"#25、-页面编码和被请求的资源编码如果不一致如何处理？\" class=\"headerlink\" title=\"25、 页面编码和被请求的资源编码如果不一致如何处理？\"></a>25、 页面编码和被请求的资源编码如果不一致如何处理？</h3><p>若请求的资源编码，如外引js文件编码与页面编码不同。可根据外引资源编码方式定义为 charset=”utf-8”或”gbk”。<br>比如：<code>http://www.yyy.com/a.html</code> 中嵌入了一个<code>http://www.xxx.com/test.js</code><br>a.html 的编码是gbk或gb2312的。而引入的js编码为utf-8的 ，那就需要在引入的时候<br><code>&lt;script src=&quot;http://www.xxx.com/test.js&amp;quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</code></p>\n<h3 id=\"26、-模块化开发怎么做？\"><a href=\"#26、-模块化开发怎么做？\" class=\"headerlink\" title=\"26、 模块化开发怎么做？\"></a>26、 模块化开发怎么做？</h3><p>模块化开发指的是在解决某一个复杂问题或者一系列问题时，依照一种分类的思维把问题进行系统性的分解。模块化是一种将复杂系统分解为代码结构更合理，可维护性更高的可管理的模块方式。对于软件行业：系统被分解为一组高内聚，低耦合的模块。<br>（1）定义封装的模块<br>（2）定义新模块对其他模块的依赖<br>（3）可对其他模块的引入支持。在JavaScript中出现了一些非传统模块开发方式的规范。CommonJS的模块规范，AMD（Asynchronous Module Definition），CMD（Common Module Definition）等。AMD是异步模块定义，所有的模块将被异步加载，模块加载不影响后边语句运行。</p>\n<h3 id=\"27、-AMD（Modules-Asynchronous-Definition）、CMD（Common-Module-Definition）规范区别？\"><a href=\"#27、-AMD（Modules-Asynchronous-Definition）、CMD（Common-Module-Definition）规范区别？\" class=\"headerlink\" title=\"27、 AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？\"></a>27、 AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？</h3><p>AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。<br>区别：</p>\n<ol>\n<li>对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。</li>\n<li>CMD 推崇依赖就近，AMD 推崇依赖前置。</li>\n<li>AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// CMD</span></span><br><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"><span class=\"built_in\">require</span>, <span class=\"built_in\">exports</span>, <span class=\"built_in\">module</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./a&#x27;</span>)</span><br><span class=\"line\">    a.doSomething()</span><br><span class=\"line\">    <span class=\"comment\">// 此处略去 100 行</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./b&#x27;</span>) <span class=\"comment\">// 依赖可以就近书写</span></span><br><span class=\"line\">    b.doSomething()</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// AMD 默认推荐</span></span><br><span class=\"line\">define([<span class=\"string\">&#x27;./a&#x27;</span>, <span class=\"string\">&#x27;./b&#x27;</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123; <span class=\"comment\">// 依赖必须一开始就写好</span></span><br><span class=\"line\">    a.doSomething();</span><br><span class=\"line\">    <span class=\"comment\">// 此处略去 100 行</span></span><br><span class=\"line\">    b.doSomething();</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"28、requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何缓存的？）\"><a href=\"#28、requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何缓存的？）\" class=\"headerlink\" title=\"28、requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何缓存的？）\"></a>28、requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何缓存的？）</h3><p>核心是js的加载模块，通过正则匹配模块以及模块的依赖关系，保证文件加载的先后顺序，根据文件的路径对加载过的文件做了缓存。</p>\n<h3 id=\"29、-call和apply\"><a href=\"#29、-call和apply\" class=\"headerlink\" title=\"29、 call和apply\"></a>29、 call和apply</h3><p>call（）方法和apply（）方法的作用相同，动态改变某个类的某个方法的运行环境。他们的区别在于接收参数的方式不同。在使用call（）方法时，传递给函数的参数必须逐个列举出来。使用apply（）时，传递给函数的是参数数组。</p>\n<h3 id=\"30、-documen-write和-innerHTML的区别\"><a href=\"#30、-documen-write和-innerHTML的区别\" class=\"headerlink\" title=\"30、 documen.write和 innerHTML的区别\"></a>30、 documen.write和 innerHTML的区别</h3><p>document.write()只能重绘整个页面</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">       <span class=\"built_in\">document</span>.write(<span class=\"string\">&#x27;&lt;p&gt;5 secs later&lt;/p&gt;&#x27;</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">5000</span>);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">document</span>.write(<span class=\"string\">&quot;HI&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>innerHTML可以重绘页面的一部分</p>\n<h3 id=\"31、-回流与重绘\"><a href=\"#31、-回流与重绘\" class=\"headerlink\" title=\"31、 回流与重绘\"></a>31、 回流与重绘</h3><p>当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树。完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘</p>\n<h3 id=\"32、-DOM操作\"><a href=\"#32、-DOM操作\" class=\"headerlink\" title=\"32、 DOM操作\"></a>32、 DOM操作</h3><p>（1）创建新节点<br>createDocumentFragment() //创建一个DOM片段<br>createElement() //创建一个具体的元素<br>createTextNode() //创建一个文本节点<br>（2）添加、移除、替换、插入<br>appendChild()<br>removeChild()<br>replaceChild()<br>insertBefore() //在已有的子节点前插入一个新的子节点<br>（3）查找<br>getElementsByTagName() //通过标签名称<br>getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)<br>getElementById() //通过元素Id，唯一性</p>\n<h3 id=\"33、-数组对象有哪些原生方法，列举一下\"><a href=\"#33、-数组对象有哪些原生方法，列举一下\" class=\"headerlink\" title=\"33、 数组对象有哪些原生方法，列举一下\"></a>33、 数组对象有哪些原生方法，列举一下</h3><p>pop、push、shift、unshift、splice、reverse、sort、concat、join、slice、toString、indexOf、lastIndexOf、reduce、reduceRight<br>forEach、map、filter、every、some</p>\n<h3 id=\"34、-那些操作会造成内存泄漏\"><a href=\"#34、-那些操作会造成内存泄漏\" class=\"headerlink\" title=\"34、 那些操作会造成内存泄漏\"></a>34、 那些操作会造成内存泄漏</h3><p>全局变量、闭包、DOM清空或删除时，事件未清除、子元素存在引用</p>\n<h3 id=\"35、-什么是Cookie-隔离？（或者：请求资源的时候不要带cookie怎么做）\"><a href=\"#35、-什么是Cookie-隔离？（或者：请求资源的时候不要带cookie怎么做）\" class=\"headerlink\" title=\"35、 什么是Cookie 隔离？（或者：请求资源的时候不要带cookie怎么做）\"></a>35、 什么是Cookie 隔离？（或者：请求资源的时候不要带cookie怎么做）</h3><p>通过使用多个非主要域名来请求静态文件，如果静态文件都放在主域名下，那静态文件请求的时候带有的cookie的数据提交给server是非常浪费的，还不如隔离开。</p>\n<p>因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。同时这种方式不会将cookie传入server，也减少了server对cookie的处理分析环节，提高了server的http请求的解析速度。</p>\n<h3 id=\"36、-响应事件\"><a href=\"#36、-响应事件\" class=\"headerlink\" title=\"36、 响应事件\"></a>36、 响应事件</h3><p>onclick鼠标点击某个对象；onfocus获取焦点；onblur失去焦点；onmousedown鼠标被按下</p>\n<h3 id=\"37、-flash和js通过什么类如何交互\"><a href=\"#37、-flash和js通过什么类如何交互\" class=\"headerlink\" title=\"37、 flash和js通过什么类如何交互?\"></a>37、 flash和js通过什么类如何交互?</h3><p>Flash提供了ExternalInterface接口与JavaScript通信，ExternalInterface有两个方法，call和addCallback，call的作用是让Flash调用js里的方法，addCallback是用来注册flash函数让js调用。</p>\n<h3 id=\"38、-Flash与Ajax各自的优缺点？\"><a href=\"#38、-Flash与Ajax各自的优缺点？\" class=\"headerlink\" title=\"38、 Flash与Ajax各自的优缺点？\"></a>38、 Flash与Ajax各自的优缺点？</h3><p>Flash：适合处理多媒体、矢量图形、访问机器。但对css、处理文本不足，不容易被搜索。<br>Ajax：对css、文本支持很好，但对多媒体、矢量图形、访问机器不足。</p>\n<h3 id=\"39、-有效的javascript变量定义规则\"><a href=\"#39、-有效的javascript变量定义规则\" class=\"headerlink\" title=\"39、 有效的javascript变量定义规则\"></a>39、 有效的javascript变量定义规则</h3><p>第一个字符必须是一个字母、下划线（_）或一个美元符号（$）；其他字符可以是字母、下划线、美元符号或数字。</p>\n<h3 id=\"40、-XML与JSON的区别？\"><a href=\"#40、-XML与JSON的区别？\" class=\"headerlink\" title=\"40、 XML与JSON的区别？\"></a>40、 XML与JSON的区别？</h3><ol>\n<li>数据体积方面。JSON相对于XML来讲，数据的体积小，传递的速度更快些。</li>\n<li>数据交互方面。JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。</li>\n<li>数据描述方面。JSON对数据的描述性比XML较差。</li>\n<li>传输速度方面。JSON的速度要远远快于XML。</li>\n</ol>\n<h3 id=\"41、-HTML与XML的区别？\"><a href=\"#41、-HTML与XML的区别？\" class=\"headerlink\" title=\"41、 HTML与XML的区别？\"></a>41、 HTML与XML的区别？</h3><p>（1）XML用来传输和存储数据，HTML用来显示数据；<br>（2）XML使用的标签不用预先定义<br>（3）XML标签必须成对出现<br>（4）XML对大小写敏感<br>（5）XML中空格不会被删减<br>（6）XML中所有特殊符号必须用编码表示<br>（7）XML中的图片必须有文字说明</p>\n<h3 id=\"42、-渐进增强与优雅降级\"><a href=\"#42、-渐进增强与优雅降级\" class=\"headerlink\" title=\"42、 渐进增强与优雅降级\"></a>42、 渐进增强与优雅降级</h3><p>渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进，达到更好的用户体验。<br>优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p>\n<h3 id=\"43、-Web-Worker和Web-Socket？\"><a href=\"#43、-Web-Worker和Web-Socket？\" class=\"headerlink\" title=\"43、 Web Worker和Web Socket？\"></a>43、 Web Worker和Web Socket？</h3><p>web socket：在一个单独的持久连接上提供全双工、双向的通信。使用自定义的协议（ws://、wss://），同源策略对web socket不适用。<br>web worker：运行在后台的JavaScript，不影响页面的性能。<br>创建worker：var worker = new Worker(url);<br>向worker发送数据：worker.postMessage(data);<br>接收worker返回的数据：worker.onmessage<br>终止一个worker的执行：worker.terminate();</p>\n<h3 id=\"44、JS垃圾回收机制？\"><a href=\"#44、JS垃圾回收机制？\" class=\"headerlink\" title=\"44、JS垃圾回收机制？\"></a>44、JS垃圾回收机制？</h3><ol>\n<li><p>标记清除：<br>这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。<br>这个算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。定期的，垃圾回收器将从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象。从根开始，垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。</p>\n</li>\n<li><p>引用计数：<br>这是最简单的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。<br>该算法有个限制：无法处理循环引用。两个对象被创建，并互相引用，形成了一个循环。它们被调用之后不会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。</p>\n</li>\n</ol>\n<h3 id=\"45、-web应用从服务器主动推送data到客户端的方式？\"><a href=\"#45、-web应用从服务器主动推送data到客户端的方式？\" class=\"headerlink\" title=\"45、 web应用从服务器主动推送data到客户端的方式？\"></a>45、 web应用从服务器主动推送data到客户端的方式？</h3><p>JavaScript数据推送：commet（基于http长连接的服务器推送技术）。<br>基于web socket的推送：SSE（server-send Event）</p>\n<h3 id=\"46、-如何删除一个cookie？\"><a href=\"#46、-如何删除一个cookie？\" class=\"headerlink\" title=\"46、 如何删除一个cookie？\"></a>46、 如何删除一个cookie？</h3><p>1） 将cookie的失效时间设置为过去的时间（expires）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">document</span>.cookie = ‘user=’+ <span class=\"built_in\">encodeURIComponent</span>(‘name’) + <span class=\"string\">&#x27;;</span></span><br><span class=\"line\"><span class=\"string\">expires=’+ new Date(0);</span></span><br></pre></td></tr></table></figure>\n<p>2） 将系统时间设置为当前时间往前一点时间</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">date.setDate(date.getDate()-<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"47、-attribute与property的区别？\"><a href=\"#47、-attribute与property的区别？\" class=\"headerlink\" title=\"47、 attribute与property的区别？\"></a>47、 attribute与property的区别？</h3><p>attribute是dom元素在文档中作为html标签拥有的属性<br>property是dom元素在js中作为对象拥有的属性。<br>所以，对于html的标准属性来说，attribute和property是同步的，是会自动更新的。但对于自定义属性，他们不同步。</p>\n<h3 id=\"48、-Ajax请求的页面历史记录状态问题？\"><a href=\"#48、-Ajax请求的页面历史记录状态问题？\" class=\"headerlink\" title=\"48、 Ajax请求的页面历史记录状态问题？\"></a>48、 Ajax请求的页面历史记录状态问题？</h3><p>（1）通过location.hash记录状态，让浏览器记录Ajax请求时页面状态的变化。<br>（2）通过HTML5的history.pushstate，来实现浏览器地址栏的无刷新改变。</p>\n","more":"<h3 id=\"1、-介绍JavaScript的基本数据类型\"><a href=\"#1、-介绍JavaScript的基本数据类型\" class=\"headerlink\" title=\"1、 介绍JavaScript的基本数据类型\"></a>1、 介绍JavaScript的基本数据类型</h3><p>Number、String 、Boolean 、Null、Undefined<br>Object 是 JavaScript 中所有对象的父对象<br>数据封装类对象：Object、Array、Boolean、Number 和 String<br>其他对象：Function、Arguments、Math、Date、RegExp、Error<br>新类型：Symbol</p>\n<h3 id=\"2、-说说写JavaScript的基本规范？\"><a href=\"#2、-说说写JavaScript的基本规范？\" class=\"headerlink\" title=\"2、 说说写JavaScript的基本规范？\"></a>2、 说说写JavaScript的基本规范？</h3><ol>\n<li>不要在同一行声明多个变量</li>\n<li>使用 ===或!==来比较true/false或者数值</li>\n<li>switch必须带有default分支</li>\n<li>函数应该有返回值</li>\n<li>for if else 必须使用大括号</li>\n<li>语句结束加分号</li>\n<li>命名要有意义，使用驼峰命名法</li>\n</ol>\n<h3 id=\"3、-jQuery使用建议\"><a href=\"#3、-jQuery使用建议\" class=\"headerlink\" title=\"3、 jQuery使用建议\"></a>3、 jQuery使用建议</h3><ol>\n<li>尽量减少对dom元素的访问和操作</li>\n<li>尽量避免给dom元素绑定多个相同类型的事件处理函数，可以将多个相同类型事件<br>处理函数合并到一个处理函数，通过数据状态来处理分支</li>\n<li>尽量避免使用toggle事件</li>\n</ol>\n<h3 id=\"4、-Ajax使用\"><a href=\"#4、-Ajax使用\" class=\"headerlink\" title=\"4、 Ajax使用\"></a>4、 Ajax使用</h3><p>全称 ：Asynchronous Javascript And XML<br>所谓异步，就是向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。<br>创建Ajax的过程：</p>\n<ol>\n<li>创建XMLHttpRequest对象（异步调用对象）</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>创建新的Http请求（方法、URL、是否异步）</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xhr.open(‘get’,’example.php’,<span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>设置响应HTTP请求状态变化的函数。<br>onreadystatechange事件中readyState属性等于4。响应的HTTP状态为200(OK)或者304(Not Modified)。</li>\n<li>发送http请求</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xhr.send(data);</span><br></pre></td></tr></table></figure>\n\n\n<ol start=\"5\">\n<li>获取异步调用返回的数据</li>\n</ol>\n<p>注意：</p>\n<ol>\n<li>页面初次加载时，尽量在web服务器一次性输出所有相关的数据，只在页面加载完成之后，用户进行操作时采用ajax进行交互。</li>\n<li>同步ajax在IE上会产生页面假死的问题。所以建议采用异步ajax。</li>\n<li>尽量减少ajax请求次数</li>\n<li>ajax安全问题，对于敏感数据在服务器端处理，避免在客户端处理过滤。对于关键业务逻辑代码也必须放在服务器端处理。</li>\n</ol>\n<h3 id=\"5、-JavaScript有几种类型的值？你能画一下他们的内存图吗？\"><a href=\"#5、-JavaScript有几种类型的值？你能画一下他们的内存图吗？\" class=\"headerlink\" title=\"5、 JavaScript有几种类型的值？你能画一下他们的内存图吗？\"></a>5、 JavaScript有几种类型的值？你能画一下他们的内存图吗？</h3><p>基本数据类型存储在栈中，引用数据类型（对象）存储在堆中，指针放在栈中。<br>两种类型的区别是：存储位置不同；原始数据类型直接存储在栈中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；引用数据类型存储在堆中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能<br>引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</p>\n<h3 id=\"6、-栈和堆的区别？\"><a href=\"#6、-栈和堆的区别？\" class=\"headerlink\" title=\"6、 栈和堆的区别？\"></a>6、 栈和堆的区别？</h3><p>栈（stack）：由编译器自动分配释放，存放函数的参数值，局部变量等；<br>堆（heap）：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统释放。</p>\n<h3 id=\"7、-Javascript实现继承的几种方式\"><a href=\"#7、-Javascript实现继承的几种方式\" class=\"headerlink\" title=\"7、 Javascript实现继承的几种方式\"></a>7、 Javascript实现继承的几种方式</h3><p>JavaScript实现继承的3种方法<br>1）、借用构造函数法（又叫经典继承）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">window</span>.alert(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    SuperType.call(<span class=\"built_in\">this</span>, name); <span class=\"comment\">//在这里借用了父类的构造函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2）、对象冒充</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">this</span>.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">window</span>.alert(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.supertype = SuperType; <span class=\"comment\">//在这里使用了对象冒充</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.supertype(name);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3）、组合继承（最常用）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">SuperType.prototype = &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"attr\">sayName</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">window</span>.alert(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    SuperType.call(<span class=\"built_in\">this</span>, name); <span class=\"comment\">//在这里继承属性</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">SubType.prototype = <span class=\"keyword\">new</span> SuperType(); <span class=\"comment\">//这里继承方法</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"8-、Javascript创建对象的几种方式？\"><a href=\"#8-、Javascript创建对象的几种方式？\" class=\"headerlink\" title=\"8 、Javascript创建对象的几种方式？\"></a>8 、Javascript创建对象的几种方式？</h3><p>JavaScript定义类的4种方法<br>1）、工厂方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">creatPerson</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    obj.name = name;</span><br><span class=\"line\">    obj.age = age;</span><br><span class=\"line\"></span><br><span class=\"line\">    obj.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">window</span>.alert(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2）、构造函数方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">window</span>.alert(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3）、原型方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">    <span class=\"attr\">constructor</span> : Person,</span><br><span class=\"line\">    <span class=\"attr\">name</span> : <span class=\"string\">&quot;Ning&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">age</span> : <span class=\"string\">&quot;23&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">sayName</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">window</span>.alert(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">大家可以看到这种方法有缺陷，类里属性的值都是在原型里给定的。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4</span>）、组合使用构造函数和原型方法（使用最广）</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">    <span class=\"attr\">constructor</span> : Person,</span><br><span class=\"line\">    <span class=\"attr\">sayName</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">window</span>.alert(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>将构造函数方法和原型方法结合使用是目前最常用的定义类的方法。这种方法的好处是实现了属性定义和方法定义的分离。比如我可以创建两个对象<code>person1</code>和<code>person2</code>，它们分别传入各自的<code>name</code>值和<code>age</code>值，但<code>sayName()</code>方法可以同时使用原型里定义的。</p>\n<h3 id=\"9、Javascript作用链域\"><a href=\"#9、Javascript作用链域\" class=\"headerlink\" title=\"9、Javascript作用链域\"></a>9、Javascript作用链域</h3><p>作用域链的原理和原型链很类似，如果这个变量在自己的作用域中没有，那么它会寻找父级的，直到最顶层。<br>注意：JS没有块级作用域，若要形成块级作用域，可通过（function（）｛｝）（）；立即执行的形式实现。</p>\n<h3 id=\"10、-谈谈this的理解\"><a href=\"#10、-谈谈this的理解\" class=\"headerlink\" title=\"10、 谈谈this的理解\"></a>10、 谈谈this的理解</h3><ol>\n<li>this总是指向函数的直接调用者（而非间接调用者）</li>\n<li>如果有new关键字，this指向new出来的那个对象</li>\n<li>在事件中，this指向目标元素，特殊的是IE的attachEvent中的this总是指向全局对象window。</li>\n</ol>\n<h3 id=\"11、-eval是做什么的？\"><a href=\"#11、-eval是做什么的？\" class=\"headerlink\" title=\"11、 eval是做什么的？\"></a>11、 eval是做什么的？</h3><p>它的功能是把对应的字符串解析成JS代码并运行；应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。</p>\n<h3 id=\"12、-什么是window对象-什么是document对象\"><a href=\"#12、-什么是window对象-什么是document对象\" class=\"headerlink\" title=\"12、 什么是window对象? 什么是document对象?\"></a>12、 什么是window对象? 什么是document对象?</h3><p>window对象代表浏览器中打开的一个窗口。document对象代表整个html文档。实际上，document对象是window对象的一个属性。</p>\n<h3 id=\"13、-null，undefined的区别？\"><a href=\"#13、-null，undefined的区别？\" class=\"headerlink\" title=\"13、 null，undefined的区别？\"></a>13、 null，undefined的区别？</h3><p>null表示一个对象被定义了，但存放了空指针，转换为数值时为0。<br>undefined表示声明的变量未初始化，转换为数值时为NAN。<br>typeof(null) – object;<br>typeof(undefined) – undefined</p>\n<h3 id=\"14、-“1”-“2”-“3”-map-parseInt-答案是多少？\"><a href=\"#14、-“1”-“2”-“3”-map-parseInt-答案是多少？\" class=\"headerlink\" title=\"14、 [“1”, “2”, “3”].map(parseInt) 答案是多少？\"></a>14、 [“1”, “2”, “3”].map(parseInt) 答案是多少？</h3><p>[1,NaN,NaN]</p>\n<p>解析：<br>Array.prototype.map()<br>array.map(callback[, thisArg])<br>callback函数的执行规则<br>参数：自动传入三个参数<br>currentValue（当前被传递的元素）；<br>index（当前被传递的元素的索引）；<br>array（调用map方法的数组）</p>\n<p>parseInt方法接收两个参数<br>第三个参数[“1”, “2”, “3”]将被忽略。parseInt方法将会通过以下方式被调用<br>parseInt(“1”, 0)<br>parseInt(“2”, 1)<br>parseInt(“3”, 2)</p>\n<p>parseInt的第二个参数radix为0时，ECMAScript5将string作为十进制数字的字符串解析；<br>parseInt的第二个参数radix为1时，解析结果为NaN；<br>parseInt的第二个参数radix在2—36之间时，如果string参数的第一个字符（除空白以外），不属于radix指定进制下的字符，解析结果为NaN。<br>parseInt(“3”, 2)执行时，由于”3”不属于二进制字符，解析结果为NaN。</p>\n<h3 id=\"15、关于事件，IE与火狐的事件机制有什么区别？如何阻止冒泡？\"><a href=\"#15、关于事件，IE与火狐的事件机制有什么区别？如何阻止冒泡？\" class=\"headerlink\" title=\"15、关于事件，IE与火狐的事件机制有什么区别？如何阻止冒泡？\"></a>15、关于事件，IE与火狐的事件机制有什么区别？如何阻止冒泡？</h3><p>IE为事件冒泡，Firefox同时支持事件捕获和事件冒泡。但并非所有浏览器都支持事件捕获。jQuery中使用<code>event.stopPropagation()</code>方法可阻止冒泡;（旧IE的方法 <code>ev.cancelBubble = true;</code>）</p>\n<h3 id=\"16、-什么是闭包（closure），为什么要用它？\"><a href=\"#16、-什么是闭包（closure），为什么要用它？\" class=\"headerlink\" title=\"16、 什么是闭包（closure），为什么要用它？\"></a>16、 什么是闭包（closure），为什么要用它？</h3><p>闭包指的是一个函数可以访问另一个函数作用域中变量。常见的构造方法，是在一个函数内部定义另外一个函数。内部函数可以引用外层的变量；外层变量不会被垃圾回收机制回收。<br>注意，闭包的原理是作用域链，所以闭包访问的上级作用域中的变量是个对象，其值为其运算结束后的最后一个值。<br>优点：避免全局变量污染。缺点：容易造成内存泄漏。<br>例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">makeFunc</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">&quot;Mozilla&quot;</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">displayName</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> displayName;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> myFunc = makeFunc();</span><br><span class=\"line\">myFunc();   <span class=\"comment\">//输出Mozilla</span></span><br></pre></td></tr></table></figure>\n<p>myFunc 变成一个 闭包。闭包是一种特殊的对象。它由两部分构成：函数，以及创建该函数的环境。环境由闭包创建时在作用域中的任何局部变量组成。在我们的例子中，myFunc 是一个闭包，由 displayName 函数和闭包创建时存在的 “Mozilla” 字符串形成。</p>\n<h3 id=\"17、javascript-代码中的”use-strict”-是什么意思-使用它区别是什么？\"><a href=\"#17、javascript-代码中的”use-strict”-是什么意思-使用它区别是什么？\" class=\"headerlink\" title=\"17、javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？\"></a>17、javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？</h3><p>除了正常模式运行外，ECMAscript添加了第二种运行模式：“严格模式”。<br>作用：</p>\n<ol>\n<li>消除js不合理，不严谨地方，减少怪异行为</li>\n<li>消除代码运行的不安全之处，</li>\n<li>提高编译器的效率，增加运行速度</li>\n<li>为未来的js新版本做铺垫。</li>\n</ol>\n<h3 id=\"18、-如何判断一个对象是否属于某个类？\"><a href=\"#18、-如何判断一个对象是否属于某个类？\" class=\"headerlink\" title=\"18、 如何判断一个对象是否属于某个类？\"></a>18、 如何判断一个对象是否属于某个类？</h3><p>使用instanceof 即if(a instanceof Person){alert(‘yes’);}</p>\n<h3 id=\"19、-new操作符具体干了什么呢\"><a href=\"#19、-new操作符具体干了什么呢\" class=\"headerlink\" title=\"19、 new操作符具体干了什么呢?\"></a>19、 new操作符具体干了什么呢?</h3><ol>\n<li>创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。</li>\n<li>属性和方法被加入到 this 引用的对象中。</li>\n<li>新创建的对象由 this 所引用，并且最后隐式的返回 this 。</li>\n</ol>\n<h3 id=\"20、-Javascript中，执行时对象查找时，永远不会去查找原型的函数？\"><a href=\"#20、-Javascript中，执行时对象查找时，永远不会去查找原型的函数？\" class=\"headerlink\" title=\"20、 Javascript中，执行时对象查找时，永远不会去查找原型的函数？\"></a>20、 Javascript中，执行时对象查找时，永远不会去查找原型的函数？</h3><p>Object.hasOwnProperty(proName)：是用来判断一个对象是否有你给出名称的属性。不过需要注意的是，此方法无法检查该对象的原型链中是否具有该属性，该属性必须是对象本身的一个成员。</p>\n<h3 id=\"21、-对JSON的了解？\"><a href=\"#21、-对JSON的了解？\" class=\"headerlink\" title=\"21、 对JSON的了解？\"></a>21、 对JSON的了解？</h3><p>全称：JavaScript Object Notation<br>JSON中对象通过“{}”来标识，一个“{}”代表一个对象，如{“AreaId”:”123”}，对象的值是键值对的形式（key：value）。JSON是JS的一个严格的子集，一种轻量级的数据交换格式，类似于xml。数据格式简单，易于读写，占用带宽小。<br>两个函数：<br>JSON.parse(str)<br>解析JSON字符串 把JSON字符串变成JavaScript值或对象<br>JSON.stringify(obj)<br>将一个JavaScript值(对象或者数组)转换为一个 JSON字符串<br>eval(‘(‘＋json＋’)’)<br>用eval方法注意加括号 而且这种方式更容易被攻击</p>\n<h3 id=\"22、-JS延迟加载的方式有哪些？\"><a href=\"#22、-JS延迟加载的方式有哪些？\" class=\"headerlink\" title=\"22、 JS延迟加载的方式有哪些？\"></a>22、 JS延迟加载的方式有哪些？</h3><p>JS的延迟加载有助与提高页面的加载速度。<br>defer和async、动态创建DOM方式（用得最多）、按需异步载入JS<br>defer：延迟脚本。立即下载，但延迟执行（延迟到整个页面都解析完毕后再运行），按照脚本出现的先后顺序执行。<br>async：异步脚本。下载完立即执行，但不保证按照脚本出现的先后顺序执行。</p>\n<h3 id=\"23、-同步和异步的区别\"><a href=\"#23、-同步和异步的区别\" class=\"headerlink\" title=\"23、 同步和异步的区别?\"></a>23、 同步和异步的区别?</h3><p>同步的概念在操作系统中：不同进程协同完成某项工作而先后次序调整（通过阻塞、唤醒等方式），同步强调的是顺序性，谁先谁后。异步不存在顺序性。<br>同步：浏览器访问服务器，用户看到页面刷新，重新发请求，等请求完，页面刷新，新内容出现，用户看到新内容之后进行下一步操作。<br>异步：浏览器访问服务器请求，用户正常操作，浏览器在后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容。</p>\n<h3 id=\"24、-什么是跨域问题-，如何解决跨域问题\"><a href=\"#24、-什么是跨域问题-，如何解决跨域问题\" class=\"headerlink\" title=\"24、 什么是跨域问题 ，如何解决跨域问题?\"></a>24、 什么是跨域问题 ，如何解决跨域问题?</h3><p><strong>什么是跨域？</strong><br>要明白什么是跨域之前，首先要明白什么是<strong>同源策略？</strong></p>\n<p>同源策略就是用来限制从一个源加载的文档或脚本与来自另一个源的资源进行交互。那怎样判断是否是同源呢？</p>\n<p>如果协议，端口（如果指定了）和主机对于两个页面是相同的，则两个页面具有相同的源，也就是同源。也就是说，要同时满足以下3个条件，才能叫同源：</p>\n<p>协议相同</p>\n<p>端口相同</p>\n<p>主机相同</p>\n<p>举个例子就一目了然了：</p>\n<p>我们来看下面的页面是否与 <code>http://store.company.com/dir/index.html</code> 是同源的？</p>\n<p><code>http://store.company.com/dir/index2.html </code>同源</p>\n<p><code>http://store.company.com/dir2/index3.html </code>同源 虽然在不同文件夹下</p>\n<p><code>https://store.company.com/secure.html </code>不同源 不同的协议(https)</p>\n<p><code>http://store.company.com:81/dir/index.html </code>不同源 不同的端口(81)</p>\n<p><code>http://news.company.com/dir/other.html </code>不同源 不同的主机(news)</p>\n<p>跨域的几种解决方案</p>\n<h4 id=\"1）、document-domain方法\"><a href=\"#1）、document-domain方法\" class=\"headerlink\" title=\"1）、document.domain方法\"></a>1）、document.domain方法</h4><p>我们来看一个具体场景：有一个页面 <a href=\"http://www.example.com/a.html\">http://www.example.com/a.html</a> ，它里面有一个iframe，这个iframe的源是 <a href=\"http://example.com/b.html\">http://example.com/b.html</a> ，很显然它们是不同源的，所以我们无法在父页面中操控子页面的内容。</p>\n<p>解决方案如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- b.html --&gt;</span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"><span class=\"built_in\">document</span>.domain = <span class=\"string\">&#x27;example.com&#x27;</span>;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- a.html --&gt;</span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"><span class=\"built_in\">document</span>.domain = <span class=\"string\">&#x27;example.com&#x27;</span>;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"><span class=\"keyword\">var</span> iframe = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;iframe&#x27;</span>).contentWindow.document;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"><span class=\"comment\">//后面就可以操作iframe里的内容了...</span></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>所以我们只要将两个页面的document.domain设置成一致就可以了，要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域。</p>\n<p>但是，这种方法只能解决主域相同的跨域问题。</p>\n<h4 id=\"2）、window-name方法\"><a href=\"#2）、window-name方法\" class=\"headerlink\" title=\"2）、window.name方法\"></a>2）、window.name方法</h4><p>window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。</p>\n<p>我们来看一个具体场景，在一个页面 <code>example.com/a.html </code>中，我们想获取 <code>data.com/data.html </code>中的数据，以下是解决方案：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- data.html --&gt;</span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"><span class=\"built_in\">window</span>.name = <span class=\"string\">&#x27;data&#x27;</span>; <span class=\"comment\">//这是就是我们需要通信的数据</span></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- a.html --&gt;</span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getData</span> (<span class=\"params\"></span>) </span>&#123;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">        <span class=\"keyword\">var</span> iframe = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;iframe&#x27;</span>);</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">        iframe.src = <span class=\"string\">&#x27;example.com/b.html&#x27;</span>; <span class=\"comment\">// 这里让iframe与父页面同源</span></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">        </span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">        iframe.onload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">            <span class=\"keyword\">var</span> data = iframe.contentWindow.name; <span class=\"comment\">//在这里我们得到了跨域页面中传来的数据</span></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">        &#125;;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">    &#125;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3）、JSONP方法\"><a href=\"#3）、JSONP方法\" class=\"headerlink\" title=\"3）、JSONP方法\"></a>3）、JSONP方法</h4><p>JONSP(JSON with Padding)是JSON的一种使用模式。基本原理如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- a.html --&gt;</span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dealData</span> (<span class=\"params\">data</span>) </span>&#123;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">        <span class=\"built_in\">console</span>.log(data);</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">    &#125;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&#x27;http://example.com/data.php?callback=dealData&#x27;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php</span><br><span class=\"line\">    $callback = $_GET[<span class=\"string\">&#x27;callback&#x27;</span>];</span><br><span class=\"line\">    $data = <span class=\"string\">&#x27;data&#x27;</span>;</span><br><span class=\"line\">    echo $callback.<span class=\"string\">&#x27;(&#x27;</span>.json_encode($data).<span class=\"string\">&#x27;)&#x27;</span>;</span><br><span class=\"line\">?&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这时候在<code>a.html</code>中我们得到了一条js的执行语句<code>dealData(&#39;data&#39;)</code>，从而达到了跨域的目的。</p>\n<p>所以JSONP的原理其实就是利用引入<code>script</code>不限制源的特点，把处理函数名作为参数传入，然后返回执行语句，仔细阅读以上代码就可以明白里面的意思了。</p>\n<p>如果在jQuery中用JSONP的话就更加简单了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">$.getJSON(<span class=\"string\">&#x27;&#x27;</span>http:<span class=\"comment\">//example.com/data.php?callback=?&#x27;, function (data) &#123;</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>注意jQuery会自动生成一个全局函数来替换<code>callback=?</code>中的问号，之后获取到数据后又会自动销毁，实际上就是起一个临时代理函数的作用。<code>$.getJSON</code>方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法；跨域的话，则会以异步加载js文件的形式来调用JSONP的回调函数。</p>\n<h3 id=\"25、-页面编码和被请求的资源编码如果不一致如何处理？\"><a href=\"#25、-页面编码和被请求的资源编码如果不一致如何处理？\" class=\"headerlink\" title=\"25、 页面编码和被请求的资源编码如果不一致如何处理？\"></a>25、 页面编码和被请求的资源编码如果不一致如何处理？</h3><p>若请求的资源编码，如外引js文件编码与页面编码不同。可根据外引资源编码方式定义为 charset=”utf-8”或”gbk”。<br>比如：<code>http://www.yyy.com/a.html</code> 中嵌入了一个<code>http://www.xxx.com/test.js</code><br>a.html 的编码是gbk或gb2312的。而引入的js编码为utf-8的 ，那就需要在引入的时候<br><code>&lt;script src=&quot;http://www.xxx.com/test.js&amp;quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</code></p>\n<h3 id=\"26、-模块化开发怎么做？\"><a href=\"#26、-模块化开发怎么做？\" class=\"headerlink\" title=\"26、 模块化开发怎么做？\"></a>26、 模块化开发怎么做？</h3><p>模块化开发指的是在解决某一个复杂问题或者一系列问题时，依照一种分类的思维把问题进行系统性的分解。模块化是一种将复杂系统分解为代码结构更合理，可维护性更高的可管理的模块方式。对于软件行业：系统被分解为一组高内聚，低耦合的模块。<br>（1）定义封装的模块<br>（2）定义新模块对其他模块的依赖<br>（3）可对其他模块的引入支持。在JavaScript中出现了一些非传统模块开发方式的规范。CommonJS的模块规范，AMD（Asynchronous Module Definition），CMD（Common Module Definition）等。AMD是异步模块定义，所有的模块将被异步加载，模块加载不影响后边语句运行。</p>\n<h3 id=\"27、-AMD（Modules-Asynchronous-Definition）、CMD（Common-Module-Definition）规范区别？\"><a href=\"#27、-AMD（Modules-Asynchronous-Definition）、CMD（Common-Module-Definition）规范区别？\" class=\"headerlink\" title=\"27、 AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？\"></a>27、 AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？</h3><p>AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。<br>区别：</p>\n<ol>\n<li>对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。</li>\n<li>CMD 推崇依赖就近，AMD 推崇依赖前置。</li>\n<li>AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// CMD</span></span><br><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"><span class=\"built_in\">require</span>, <span class=\"built_in\">exports</span>, <span class=\"built_in\">module</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./a&#x27;</span>)</span><br><span class=\"line\">    a.doSomething()</span><br><span class=\"line\">    <span class=\"comment\">// 此处略去 100 行</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./b&#x27;</span>) <span class=\"comment\">// 依赖可以就近书写</span></span><br><span class=\"line\">    b.doSomething()</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// AMD 默认推荐</span></span><br><span class=\"line\">define([<span class=\"string\">&#x27;./a&#x27;</span>, <span class=\"string\">&#x27;./b&#x27;</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123; <span class=\"comment\">// 依赖必须一开始就写好</span></span><br><span class=\"line\">    a.doSomething();</span><br><span class=\"line\">    <span class=\"comment\">// 此处略去 100 行</span></span><br><span class=\"line\">    b.doSomething();</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"28、requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何缓存的？）\"><a href=\"#28、requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何缓存的？）\" class=\"headerlink\" title=\"28、requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何缓存的？）\"></a>28、requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何缓存的？）</h3><p>核心是js的加载模块，通过正则匹配模块以及模块的依赖关系，保证文件加载的先后顺序，根据文件的路径对加载过的文件做了缓存。</p>\n<h3 id=\"29、-call和apply\"><a href=\"#29、-call和apply\" class=\"headerlink\" title=\"29、 call和apply\"></a>29、 call和apply</h3><p>call（）方法和apply（）方法的作用相同，动态改变某个类的某个方法的运行环境。他们的区别在于接收参数的方式不同。在使用call（）方法时，传递给函数的参数必须逐个列举出来。使用apply（）时，传递给函数的是参数数组。</p>\n<h3 id=\"30、-documen-write和-innerHTML的区别\"><a href=\"#30、-documen-write和-innerHTML的区别\" class=\"headerlink\" title=\"30、 documen.write和 innerHTML的区别\"></a>30、 documen.write和 innerHTML的区别</h3><p>document.write()只能重绘整个页面</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">       <span class=\"built_in\">document</span>.write(<span class=\"string\">&#x27;&lt;p&gt;5 secs later&lt;/p&gt;&#x27;</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">5000</span>);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">document</span>.write(<span class=\"string\">&quot;HI&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>innerHTML可以重绘页面的一部分</p>\n<h3 id=\"31、-回流与重绘\"><a href=\"#31、-回流与重绘\" class=\"headerlink\" title=\"31、 回流与重绘\"></a>31、 回流与重绘</h3><p>当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树。完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘</p>\n<h3 id=\"32、-DOM操作\"><a href=\"#32、-DOM操作\" class=\"headerlink\" title=\"32、 DOM操作\"></a>32、 DOM操作</h3><p>（1）创建新节点<br>createDocumentFragment() //创建一个DOM片段<br>createElement() //创建一个具体的元素<br>createTextNode() //创建一个文本节点<br>（2）添加、移除、替换、插入<br>appendChild()<br>removeChild()<br>replaceChild()<br>insertBefore() //在已有的子节点前插入一个新的子节点<br>（3）查找<br>getElementsByTagName() //通过标签名称<br>getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)<br>getElementById() //通过元素Id，唯一性</p>\n<h3 id=\"33、-数组对象有哪些原生方法，列举一下\"><a href=\"#33、-数组对象有哪些原生方法，列举一下\" class=\"headerlink\" title=\"33、 数组对象有哪些原生方法，列举一下\"></a>33、 数组对象有哪些原生方法，列举一下</h3><p>pop、push、shift、unshift、splice、reverse、sort、concat、join、slice、toString、indexOf、lastIndexOf、reduce、reduceRight<br>forEach、map、filter、every、some</p>\n<h3 id=\"34、-那些操作会造成内存泄漏\"><a href=\"#34、-那些操作会造成内存泄漏\" class=\"headerlink\" title=\"34、 那些操作会造成内存泄漏\"></a>34、 那些操作会造成内存泄漏</h3><p>全局变量、闭包、DOM清空或删除时，事件未清除、子元素存在引用</p>\n<h3 id=\"35、-什么是Cookie-隔离？（或者：请求资源的时候不要带cookie怎么做）\"><a href=\"#35、-什么是Cookie-隔离？（或者：请求资源的时候不要带cookie怎么做）\" class=\"headerlink\" title=\"35、 什么是Cookie 隔离？（或者：请求资源的时候不要带cookie怎么做）\"></a>35、 什么是Cookie 隔离？（或者：请求资源的时候不要带cookie怎么做）</h3><p>通过使用多个非主要域名来请求静态文件，如果静态文件都放在主域名下，那静态文件请求的时候带有的cookie的数据提交给server是非常浪费的，还不如隔离开。</p>\n<p>因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。同时这种方式不会将cookie传入server，也减少了server对cookie的处理分析环节，提高了server的http请求的解析速度。</p>\n<h3 id=\"36、-响应事件\"><a href=\"#36、-响应事件\" class=\"headerlink\" title=\"36、 响应事件\"></a>36、 响应事件</h3><p>onclick鼠标点击某个对象；onfocus获取焦点；onblur失去焦点；onmousedown鼠标被按下</p>\n<h3 id=\"37、-flash和js通过什么类如何交互\"><a href=\"#37、-flash和js通过什么类如何交互\" class=\"headerlink\" title=\"37、 flash和js通过什么类如何交互?\"></a>37、 flash和js通过什么类如何交互?</h3><p>Flash提供了ExternalInterface接口与JavaScript通信，ExternalInterface有两个方法，call和addCallback，call的作用是让Flash调用js里的方法，addCallback是用来注册flash函数让js调用。</p>\n<h3 id=\"38、-Flash与Ajax各自的优缺点？\"><a href=\"#38、-Flash与Ajax各自的优缺点？\" class=\"headerlink\" title=\"38、 Flash与Ajax各自的优缺点？\"></a>38、 Flash与Ajax各自的优缺点？</h3><p>Flash：适合处理多媒体、矢量图形、访问机器。但对css、处理文本不足，不容易被搜索。<br>Ajax：对css、文本支持很好，但对多媒体、矢量图形、访问机器不足。</p>\n<h3 id=\"39、-有效的javascript变量定义规则\"><a href=\"#39、-有效的javascript变量定义规则\" class=\"headerlink\" title=\"39、 有效的javascript变量定义规则\"></a>39、 有效的javascript变量定义规则</h3><p>第一个字符必须是一个字母、下划线（_）或一个美元符号（$）；其他字符可以是字母、下划线、美元符号或数字。</p>\n<h3 id=\"40、-XML与JSON的区别？\"><a href=\"#40、-XML与JSON的区别？\" class=\"headerlink\" title=\"40、 XML与JSON的区别？\"></a>40、 XML与JSON的区别？</h3><ol>\n<li>数据体积方面。JSON相对于XML来讲，数据的体积小，传递的速度更快些。</li>\n<li>数据交互方面。JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。</li>\n<li>数据描述方面。JSON对数据的描述性比XML较差。</li>\n<li>传输速度方面。JSON的速度要远远快于XML。</li>\n</ol>\n<h3 id=\"41、-HTML与XML的区别？\"><a href=\"#41、-HTML与XML的区别？\" class=\"headerlink\" title=\"41、 HTML与XML的区别？\"></a>41、 HTML与XML的区别？</h3><p>（1）XML用来传输和存储数据，HTML用来显示数据；<br>（2）XML使用的标签不用预先定义<br>（3）XML标签必须成对出现<br>（4）XML对大小写敏感<br>（5）XML中空格不会被删减<br>（6）XML中所有特殊符号必须用编码表示<br>（7）XML中的图片必须有文字说明</p>\n<h3 id=\"42、-渐进增强与优雅降级\"><a href=\"#42、-渐进增强与优雅降级\" class=\"headerlink\" title=\"42、 渐进增强与优雅降级\"></a>42、 渐进增强与优雅降级</h3><p>渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进，达到更好的用户体验。<br>优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p>\n<h3 id=\"43、-Web-Worker和Web-Socket？\"><a href=\"#43、-Web-Worker和Web-Socket？\" class=\"headerlink\" title=\"43、 Web Worker和Web Socket？\"></a>43、 Web Worker和Web Socket？</h3><p>web socket：在一个单独的持久连接上提供全双工、双向的通信。使用自定义的协议（ws://、wss://），同源策略对web socket不适用。<br>web worker：运行在后台的JavaScript，不影响页面的性能。<br>创建worker：var worker = new Worker(url);<br>向worker发送数据：worker.postMessage(data);<br>接收worker返回的数据：worker.onmessage<br>终止一个worker的执行：worker.terminate();</p>\n<h3 id=\"44、JS垃圾回收机制？\"><a href=\"#44、JS垃圾回收机制？\" class=\"headerlink\" title=\"44、JS垃圾回收机制？\"></a>44、JS垃圾回收机制？</h3><ol>\n<li><p>标记清除：<br>这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。<br>这个算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。定期的，垃圾回收器将从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象。从根开始，垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。</p>\n</li>\n<li><p>引用计数：<br>这是最简单的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。<br>该算法有个限制：无法处理循环引用。两个对象被创建，并互相引用，形成了一个循环。它们被调用之后不会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。</p>\n</li>\n</ol>\n<h3 id=\"45、-web应用从服务器主动推送data到客户端的方式？\"><a href=\"#45、-web应用从服务器主动推送data到客户端的方式？\" class=\"headerlink\" title=\"45、 web应用从服务器主动推送data到客户端的方式？\"></a>45、 web应用从服务器主动推送data到客户端的方式？</h3><p>JavaScript数据推送：commet（基于http长连接的服务器推送技术）。<br>基于web socket的推送：SSE（server-send Event）</p>\n<h3 id=\"46、-如何删除一个cookie？\"><a href=\"#46、-如何删除一个cookie？\" class=\"headerlink\" title=\"46、 如何删除一个cookie？\"></a>46、 如何删除一个cookie？</h3><p>1） 将cookie的失效时间设置为过去的时间（expires）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">document</span>.cookie = ‘user=’+ <span class=\"built_in\">encodeURIComponent</span>(‘name’) + <span class=\"string\">&#x27;;</span></span><br><span class=\"line\"><span class=\"string\">expires=’+ new Date(0);</span></span><br></pre></td></tr></table></figure>\n<p>2） 将系统时间设置为当前时间往前一点时间</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">date.setDate(date.getDate()-<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"47、-attribute与property的区别？\"><a href=\"#47、-attribute与property的区别？\" class=\"headerlink\" title=\"47、 attribute与property的区别？\"></a>47、 attribute与property的区别？</h3><p>attribute是dom元素在文档中作为html标签拥有的属性<br>property是dom元素在js中作为对象拥有的属性。<br>所以，对于html的标准属性来说，attribute和property是同步的，是会自动更新的。但对于自定义属性，他们不同步。</p>\n<h3 id=\"48、-Ajax请求的页面历史记录状态问题？\"><a href=\"#48、-Ajax请求的页面历史记录状态问题？\" class=\"headerlink\" title=\"48、 Ajax请求的页面历史记录状态问题？\"></a>48、 Ajax请求的页面历史记录状态问题？</h3><p>（1）通过location.hash记录状态，让浏览器记录Ajax请求时页面状态的变化。<br>（2）通过HTML5的history.pushstate，来实现浏览器地址栏的无刷新改变。</p>","categories":[{"name":"面试题","path":"api/categories/面试题.json"}],"tags":[{"name":"JavaScript基础面试题","path":"api/tags/JavaScript基础面试题.json"}]}